---
resampling_with:
    ed2_fname: null
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.5
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{r setup, include=FALSE}
source("_common.R")
```

# Two puzzles and more tools {#sec-more-sampling-tools}

## Introduction

In the next chapter we will deal with some more involved problems in
*probability*, as a preparation for *statistics*, where we use reasoning from
probability to draw conclusions in a world like our own, where there appears to
be random variation.

Before we get down to the business of complex probabilistic problems in the
next few chapters, let's consider a couple of peculiar puzzles that have uses
for us here.  The first is, that they allow us to introduce some more of the
key tools in {{< var lang >}} that we will use for Monte Carlo resampling. The
second is that these problems are extremely valuable in showing the power of
the Monte Carlo simulation method to help us solve, and then reason above,
problems in probability.

## The treasure fleet recovered

This is a classic problem in probability:[^three-coins-version]

> A Spanish treasure fleet of three ships was sunk at sea off Mexico. One ship
> had a trunk of gold forward and another aft, another ship had a trunk of gold
> forward and a trunk of silver aft, while a third ship had a trunk of silver
> forward and another trunk of silver aft. Divers just found one of the ships
> and a trunk of gold in it. They are now taking bets about whether the other
> trunk found on the same ship will contain silver or gold. What are fair odds?

[^three-coins-version]: The treasure fleet problem is a restatement of [a
    problem that Joseph Bertrand
    posed](https://en.wikipedia.org/wiki/Bertrand%27s_box_paradox) early in the
    19th century.)  Here is a variation from [@goldberg1986probability, page
    99]:

    > Three identical boxes each contain two coins. In one box both are
    > pennies, in the second both are nickels, and in the third there is one
    > penny and one nickel.
    >
    > A man chooses a box at random and takes out a coin. If the coin is a
    > penny, what is the probability that the other coin in the box is also a
    > penny?

These are the logical steps one may distinguish in arriving at a correct
answer with deductive logic (portrayed in @fig-ships-gold-silver).

1.  Postulate three ships â€” Ship I with two gold chests (G-G), ship II
    with one gold and one silver chest (G-S), and ship III with S-S.
    (Choosing notation might well be considered one or more additional
    steps.)
2.  Assert equal probabilities of each ship being found.
3.  Step 2 implies equal probabilities of being found for each of the
    six chests.
4.  Fact: Diver finds a chest of gold.
5.  Step 4 implies that S-S ship III was not found; hence remove it from
    subsequent analysis.
6.  Three possibilities: 6a) Diver found chest I-Ga, 6b) diver found
    I-Gb, 6c) diver found II-Gc.

    From step 2, the cases a, b, and c in step 6 have equal
    probabilities.
7.  If possibility 6a is the case, then the other trunk is I-Gb; the
    comparable statements for cases 6b and 6c are I-Ga and II-S.
8.  From steps 6 and 7: From equal probabilities of the three cases, and
    no other possible outcome, $P(6a) = 1/3$, $P(6b) = 1/3$, $P(6c) =
    1/3$.
9.  So $P(G) = P(6a) + P(6b)$ = 1/3 + 1/3 = 2/3.

See @fig-ships-gold-silver.

```{r fig-ships-gold-silver, opts.label="svg_fig", fig.cap="Ships with Gold and Silver"}
include_svg('diagrams/ships_gold_silver.svg')
```

The following simulation arrives at the correct answer:

1.  Write "Gold" on three pieces of paper and "Silver" on three pieces of
    paper.
2.  Get three buckets each with two pieces of paper:  one with "Gold", "Gold",
    one with "Gold", "Silver", and one with "Silver", "Silver".
3.  Choose a bucket at random, and shuffle the pieces of paper in it.
4.  Choose the first element in the chosen bucket's vector (a vector is an
    array or list of things). If "Silver", stop trial and make no further
    record. If "Gold", continue.
5.  Record the second element in the chosen bucket's vector on the
    scoreboard.
6.  Repeat steps (3 - 5), and calculate the proportion of "Gold"'s on a
    scoreboard. (The answer should be about $\frac{2}{3}$.)

<!---
Consider introducing elif here.
-->

Here is a notebook simulation with {{< var lang >}}:

::: {.notebook name="gold_silver_ships" title="Ships with gold and silver"}

::: nb-only
In which we solve the problem of gold and silver chests in a discovered ship.
:::

```{python}
import numpy as np
rnd = np.random.default_rng()
```

```{python}
# The 3 buckets, each representing two trunks on a ship.
bucket1 = ['Gold', 'Gold']  # Trunks in first ship.
bucket2 = ['Gold',  'Silver']  # Trunks in second ship.
bucket3 = ['Silver', 'Silver']  # Trunks in third ship.
```

```{python}
# Mark trials as not valid to start with.
# Trials where we don't get a gold trunk first will
# keep this 'No gold in first trunk' marker.
second_trunks = np.repeat(['No gold in first trunk'], 10000)

for i in range(10000):
    # Select a ship at random from the three ships.
    ship_no = rnd.choice([1, 2, 3])
    # Get the trunks from this ship.
    if ship_no == 1:
        bucket = bucket1
    if ship_no == 2:
        bucket = bucket2
    if ship_no == 3:
        bucket = bucket3

    shuffled = rnd.permuted(bucket)

    if shuffled[0] == 'Gold':  # We found a gold trunk first.
        # Store whether the Second trunk was silver or gold.
        second_trunks[i] = shuffled[1]

# End loop, go back to beginning.

# Number of times we found gold in the second trunk.
n_golds = np.sum(second_trunks == 'Gold')
# Number of times we found silver in the second trunk.
n_silvers = np.sum(second_trunks == 'Silver')
# As a ratio of golds to all second trunks (where the first was gold).
print(n_golds / (n_golds + n_silvers))
```

```{r}
# The 3 buckets, each representing two trunks on a ship.
bucket1 <- c('Gold', 'Gold')  # Trunks in first ship.
bucket2 <- c('Gold',  'Silver')  # Trunks in second ship.
bucket3 <- c('Silver', 'Silver')  # Trunks in third ship.
```

```{r}
# Mark trials as not valid to start with.
# Trials where we don't get a gold trunk first will
# keep this 'No gold in first trunk' marker.
second_trunks <- rep('No gold in first trunk', 10000)

for (i in 1:10000) {
    # Select a ship at random from the three ships.
    ship_no <- sample(1:3, size=1)
    # Get the trunks from this ship.
    if (ship_no == 1) {
        bucket <- bucket1
    }
    if (ship_no == 2) {
        bucket <- bucket2
    }
    if (ship_no == 3) {
        bucket <- bucket3
    }

    shuffled <- sample(bucket)

    if (shuffled[1] == 'Gold') {  # We found a gold trunk first.
        # Store whether the Second trunk was silver or gold.
        second_trunks[i] <- shuffled[2]
    }
}  # End loop, go back to beginning.

# Number of times we found gold in the second trunk.
n_golds <- sum(second_trunks == 'Gold')
# Number of times we found silver in the second trunk.
n_silvers <- sum(second_trunks == 'Silver')
# As a ratio of golds to all second trunks (where the first was gold).
message(n_golds / (n_golds + n_silvers))
```

:::


## Back to Boolean {{< var array >}}s

The code above implements the procedure we might well use if were were
simulating the problem physically.  We do a trial, and we record the result.
We do this on a piece of paper if we are doing a physical simulation, and in
the `second_trunks` {{< var array >}} in code.

Finally we tally up the results.  If we are doing a physical simulation, we go
back over the all the trial results and counting up the "Gold" and "Silver"
outcomes.  In code we use the comparisons `== 'Gold'` and `== 'Silver'` to find
the trials of interest, and then count them up with {{< var sum >}}.

Boolean {{< var array >}}s are a fundamental tool in {{< var lang >}}, and we will use them in nearly all our simulations.

Here is a remind of how those {{< var array >}}s work.

First, let's slice out the first 10 values of the `second_trunks`
trial-by-trial results tally from the simulation above:

```{python}
# Get values at positions 0 through 9 (up to, but not including position 10)
first_10_trunks = second_trunks[:10]
first_10_trunks
```

```{r}
# Get values at positions 1 through 10
first_10_trunks <- second_trunks[1:10]
first_10_trunks
```

Before we started the simulation, we set `second_trunks` to contain 10,000
strings, where each string was "No gold in first trunk".  In the simulation, we
check whether there was gold in the first trunk, and, if not, we don't change
the value in `second_trunk`, and the value remains as "No gold in first trunk".

Only if there was gold in the first trunk, do we go on to check whether the
second trunk contains silver or gold.  Therefore, we only set a new value in `second_trunks` where there was gold in the first trunk.

Now let us show the effect of running a comparison on `first_10_trunks`:

```{python}
were_gold = first_10_trunks == 'Gold'
were_gold
```

```{r}
were_gold <- first_10_trunks == 'Gold'
were_gold
```

The `== 'Gold'` *comparison* is asking a question.  It is asking that question
of {{< var an_array >}}, and the {{< var array >}} contains multiple values.
{{< var np_or_r >}} treats this comparison as asking the question *of each
element in the {{< var array >}}*.  We get an answer for the question *for each
element*.  The answer for position [1]{.r}[0]{.python} is {{< var true >}} if
the element at position [1]{.r}[0]{.python} is equal to `'Gold'` and {{< var
false >}} otherwise, and so on, for positions [2]{.r}[1]{.python},
[3]{.r}[2]{.python} and so on.  We started with 10 strings.  After the
comparison `== 'Gold'` we have 10 Boolean values, where a Boolean value can
either be {{< var true >}} or {{< var false >}}.

<!---
We need an illustration here of form:

True        "Gold"
True        "Gold"
False       "No gold in first trunk"
True        "Gold"
False   =   "Silver"                     == 'Gold'
...

Any takers?  Good techniques?   Maybe generated Markdown table with transparent boerder for second and fourth column?
-->

Now we have an array with {{< var true >}} for the "Gold" results and {{< var
false >}} otherwise, we can count the number of "Gold" results by using {{< var
sum >}} on the {{< var array >}}.  As you remember {{< var sum >}} counts {{<
var true >}} as 1 and {{< var false >}} as 0, so the sum of the Boolean {{< var
array >}} is just the number of {{< var true >}} values in the {{< var array
>}} â€” the count that we need.

```{python}
# The number of True values â€” so the number of "Gold" trunks.
np.sum(were_gold)
```

```{r}
# The number of True values â€” so the number of "Gold" trunks.
sum(were_gold)
```

## Boolean {{< var array >}}s and another take on the ships problem {#sec-ships-booleans}


If we are doing a physical simulation, we usually want to finish up all the work for the trial during the trial, so we have one outcome from the trial.  This makes it easier to tally up the results in the end.

We have no such constraint when we are using code, so it is sometimes easier to
record several results from the trial, and do the final combinations and
tallies at the end.   We will show you what we mean with a slight variation on
the two-ships code you saw above.

::: {.notebook name="gold_silver_booleans" title="Another approach to ships with gold and silver"}

::: nb-only
This notebook is a variation on the problem with gold and silver trunks in
ships.  It shows how we can count and tally the results at the end, rather than in the trial itself.
:::

Notice that the first part of the code is identical to the first approach to
this problem.  There are two key differences â€” see the comments for an
explanation.

```{python}
import numpy as np
rnd = np.random.default_rng()
```

```{python}
# The 3 buckets, each representing two trunks on a ship.
# As before.
bucket1 = ['Gold', 'Gold']  # Trunks in first ship.
bucket2 = ['Gold',  'Silver']  # Trunks in second ship.
bucket3 = ['Silver', 'Silver']  # Trunks in third ship.
```

```{python}
# Here is where the difference starts.  We are now going to fill in
# the result for the first trunk _and_ the result for the second trunk.
#
# Later we will fill in all these values, so the string we put here
# does not matter.

# Whether the first trunk was Gold or Silver.
first_trunks = np.repeat(['To be announced'], 10000)
# Whether the second trunk was Gold or Silver.
second_trunks = np.repeat(['To be announced'], 10000)

for i in range(10000):
    # Select a ship at random from the three ships.
    # As before.
    ship_no = rnd.choice([1, 2, 3])
    # Get the trunks from this ship.
    # As before.
    if ship_no == 1:
        bucket = bucket1
    if ship_no == 2:
        bucket = bucket2
    if ship_no == 3:
        bucket = bucket3

    # As before.
    shuffled = rnd.permuted(bucket)

    # Here is the big difference - we store the result for the first and second
    # trunks.
    first_trunks[i] = shuffled[0]
    second_trunks[i] = shuffled[1]

# End loop, go back to beginning.

# We will do the calculation we need in the next cell.  For now
# just display the first 10 values.
ten_first_trunks = first_trunks[:10]
print('The first 10 values of "first_trunks:', ten_first_trunks)
ten_second_trunks = second_trunks[:10]
print('The first 10 values of "second_trunks', ten_second_trunks)
```

```{r}
# The 3 buckets, each representing two trunks on a ship.
# As before.
bucket1 <- c('Gold', 'Gold')  # Trunks in first ship.
bucket2 <- c('Gold',  'Silver')  # Trunks in second ship.
bucket3 <- c('Silver', 'Silver')  # Trunks in third ship.
```

```{r}
# Here is where the difference starts.  We are now going to fill in
# the result for the first trunk _and_ the result for the second trunk.
#
# Later we will fill in all these values, so the string we put here
# does not matter.

# Whether the first trunk was Gold or Silver.
first_trunks <- rep('To be announced', 10000)
second_trunks <- rep('To be announced', 10000)

for (i in 1:10000) {
    # Select a ship at random from the three ships.
    # As before.
    ship_no <- sample(1:3, size=1)
    # Get the trunks from this ship.
    # As before.
    if (ship_no == 1) {
        bucket <- bucket1
    }
    if (ship_no == 2) {
        bucket <- bucket2
    }
    if (ship_no == 3) {
        bucket <- bucket3
    }

    # As before.
    shuffled <- sample(bucket)

    # Here is the big difference - we store the result for the first and second
    # trunks.
    first_trunks[i] <- shuffled[1]
    second_trunks[i] <- shuffled[2]
}  # End loop, go back to beginning.

# We will do the calculation we need in the next cell.  For now
# just display the first 10 values.
ten_first_trunks <- first_trunks[1:10]
message('The first 10 values of "first_trunks:')
print(ten_first_trunks)
ten_second_trunks <- second_trunks[1:10]
message('The first 10 values of "second_trunks:')
print(ten_second_trunks)
```

In this variant, we recorded the type of first trunk for each trial ("Gold" or
"Silver"), and the type of second trunk of the second trunk ("Gold" or
"Silver").

**We would like to count the number of times there was "Gold" in the first
trunk _and_ "Gold" in the second.**

## Combining Boolean arrays {#sec-combine-booleans}

We can do the count we need by *combining* the Boolean {{< var array >}}s with
the `&` operator.  `&` combines Boolean {{< var array >}}s with a *logical
and*. *Logical and* is a rule for combining two Boolean values, where the rule
is: the result is {{< var true >}} if the first value is {{< var true >}}
*and* the second value if {{< var true >}}.

Here we use the `&` *operator* to combine some Boolean values on the left and right of the operator:

```{python}
True & True   # Both are True, so result is True
```

```{python}
True & False   # At least one of the values is False, so result is False
```

```{python}
False & True   # At least one of the values is False, so result is False
```

```{python}
False & False   # At least one (in fact both) are False, result is False.
```

::: python

:::{.callout-note}
## `&` and `and` in Python

In fact Python has another operation to apply this *logical and* operation to values â€” the `and` operator:

```{python}
print(True and True)
print(True and False)
print(False and True)
print(False and False)
```

You will see this `and` operator often in Python code, but it does not work
well when combining Numpy *arrays*, so we will use the similar `&` operator,
that does work on arrays.

:::

```{r}
TRUE & TRUE   # Both are TRUE, so result is TRUE
```

```{r}
TRUE & FALSE   # At least one of the values is FALSE, so result is FALSE
```

```{r}
FALSE & TRUE   # At least one of the values is FALSE, so result is FALSE
```

```{r}
FALSE & FALSE   # At least one (in fact both) are FALSE, result is FALSE.
```
:::

Above you saw that the `==` operator (as in `== 'Gold'`), when applied to {{<
var array >}}s, asks the question of every element in the {{< var array >}}.

First make the Boolean {{< var array >}}s.

```{python}
ten_first_gold = ten_first_trunks == 'Gold'
print("Ten first == 'Gold'", ten_first_gold)
ten_second_gold = ten_second_trunks == 'Gold'
print("Ten second == 'Gold'", ten_second_gold)
```

```{r}
ten_first_gold <- ten_first_trunks == 'Gold'
message("Ten first == 'Gold'")
print(ten_first_gold)
ten_second_gold <- ten_second_trunks == 'Gold'
message("Ten second == 'Gold'")
print(ten_second_gold)
```

Now let us use `&` to combine to Boolean {{< var array >}}s:

```{python}
ten_both = ten_first_gold & ten_second_gold
ten_both
```

```{r}
ten_both <- ten_first_gold & ten_second_gold
ten_both
```

Notice that {{< var lang >}} does the comparison *elementwise* â€” element by
element.

You saw that when we did `second_trunks == 'Gold'` this had the effect of
asking the `== 'Gold'` question of *each element*, so there will be one answer
per element in `second_trunks`.  In that case there was {{< var an_array >}} to the *left* of `==` and a single value to the *right*.  We were comparing {{< var an_array >}} to a value.

Here we are asking the `&` question of `ten_first_gold` and `ten_second_gold`.  Here there is {{< var an_array >}} to the *left* and {{< var an_array >}} to the *right*.  We are asking the `&` question 10 times, but the first question we are asking is:

```{python}
# First question, giving first element of result.
ten_first_gold[0] & ten_second_gold[0]
```

```{r}
# First question, giving first element of result.
ten_first_gold[1] & ten_second_gold[1]
```

The second question is:

```{python}
# Second question, giving second element of result.
ten_first_gold[1] & ten_second_gold[1]
```

```{python}
# Second question, giving second element of result.
ten_first_gold[2] & ten_second_gold[2]
```

and so on.  We have ten elements on *each side*, and 10 answers, giving {{< var
an_array >}} (`ten_both`) of 10 elements.  Each element in `ten_both` is the
answer to the `&` question for the elements at the corresponding positions in
`ten_first_gold` and `ten_second_gold`.

We could also create the Boolean {{< var array >}}s and do the `&` operation
all in one step, like this:

```{python}
ten_both = (ten_first_trunks == 'Gold') & (ten_second_trunks == 'Gold')
ten_both
```

<!---
Another illustration here, of form (matching the text):

True          True          True
False         False         True
False         False         True
True          True          False
False    =    False    &    True
...
-->


::: python

:::{.callout-note}
## Parentheses, arrays and comparisons

Notice the round brackets (parentheses) around `(ten_first_trunks == 'Gold')`
and `(ten_second_trunks == 'Gold')`.  In fact, you need these to make Python do
what we want here.   Remember *operator precedence*; the multiply operator `*`
has *higher precedence* than the operator `+`, so `3 + 5 * 2` is equal to 3 +
(5 * 2) = 13.  If we want to do addition before multiplication, we use
parentheses to tell Python the order it should use: `(3 + 5) * 2` = 16.

The same applies for the two operators `==` and `&` here.   In fact `&` has a
higher precedence than `==` so Python will read the expression without
parentheses â€” `ten_first_trunks == 'Gold' & ten_second_trunks == 'Gold'` to
mean (because of operator precedence) `ten_first_trunks == ('Gold' &
ten_second_trunks) == 'Gold'`; it does not know what to do with `'Gold' &
ten_second_trunks` and generates an error:

```{python tags=c("raises-exception"), error=TRUE}
# The statement without parentheses generates an error, because of the
# "Gold' & ten_second_trunks operation, from operator precedence.
ten_first_trunks == 'Gold' & ten_second_trunks == 'Gold'
```

This is the same error you get for:

```{python tags=c("raises-exception"), error=TRUE}
# The expression that causes the error.
'Gold' & ten_second_trunks
```

The point to take away is, that when you are using `&` to combine Boolean
arrays in Python, remember operator precedence, and, when in doubt, put
parentheses around the expressions on either side of `&`, as here.

```{python}
(ten_first_trunks == 'Gold') & (ten_second_trunks == 'Gold')
```

:::



Remember, we wanted the answer to the question: how many trials had "Gold" in the first trunk *and* "Gold" in the second.  We can answer that question for the first 10 trials with {{< var sum >}}:

```{python}
n_ten_both = np.sum(ten_both)
n_ten_both
```

```{r}
n_ten_both <- sum(ten_both)
n_ten_both
```

We can answer the same question for *all* the trials, in the same way:

```{python}
first_gold = first_trunks == 'Gold'
second_gold = second_trunks == 'Gold'
n_both_gold = np.sum(first_gold & second_gold)
n_both_gold
```

```{r}
first_gold <- first_trunks == 'Gold'
second_gold <- second_trunks == 'Gold'
n_both_gold <- sum(first_gold & second_gold)
n_both_gold
```

We could also do the same calculation all in one line:

```{python}
# Notice the parentheses - we need these - see above.
n_both_gold = np.sum((first_trunks == 'Gold') & (second_trunks == 'Gold'))
n_both_gold
```

```{r}
n_both_gold <- sum((first_trunks == 'Gold') & (second_trunks == 'Gold'))
n_both_gold
```

We can then count all the ships where the first trunk was gold:

```{python}
n_first_gold = np.sum(first_trunks == 'Gold')
n_first_gold
```

```{r}
n_first_gold <- sum(first_trunks == 'Gold')
n_first_gold
```

The final calculation is the proportion of second trunks that are gold, given
the first trunk was also gold:

```{python}
p_g_given_g = n_both_gold / n_first_gold
p_g_given_g
```

```{r}
p_g_given_g <- n_both_gold / n_first_gold
p_g_given_g
```

Of course we won't get exactly the same results from the two simulations, in
the same way that we won't get exactly the same results from any two runs of
the same simulation, because of the random values we are using.  But the logic
for the two simulations are the same, and we are doing many trials (10,000), so
the results will be very similar.

:::

## The Monty Hall problem

The Monty Hall Problem is a puzzle in probability that is famous for its
deceptive simplicity.  It has its own long Wikipedia page:
<https://en.wikipedia.org/wiki/Monty_Hall_problem>.

Here is the problem in the form it is best known; a letter to the columnist
[Marilyn vos Savant](https://en.wikipedia.org/wiki/Marilyn_vos_Savant),
published in Parade Magazine [-@savant1990monty]:

> Suppose youâ€™re on a game show, and youâ€™re given the choice of three doors.
> Behind one door is a car, behind the others, goats. You pick a door, say #1,
> and the host, who knows whatâ€™s behind the doors, opens another door, say #3,
> which has a goat. He says to you, "Do you want to pick door #2?" Is it to
> your advantage to switch your choice of doors?

In fact the first person to propose (and solve) this problem was Steve Selvin,
a professor of public health at the University of California, Berkeley
[@slevin1975monty].

Most people, including at least one of us, your humble authors, quickly come to
the wrong conclusion.  The most common but incorrect answer is that it will
make no difference if you switch doors or stay with your original choice.  The
obvious intuition is that, after Monty opens his door, there are two doors that
might have the car behind them, and therefore, there is a 50% chance it will be
behind any one of the two. It turns out that answer is wrong; you will double
your chances of winning by switching doors. Did you get the answer right?

If you got the answer wrong, you are in excellent company.  As you can see
from the commentary in @savant1990monty, many mathematicians wrote to Parade
magazine to assert that the (correct) solution was wrong.  [Paul
ErdÅ‘s](https://en.wikipedia.org/wiki/Paul_Erd%C5%91s) was one of the most
famous mathematicians of the 20th century; he could not be convinced of the
correct solution until he had seen a computer simulation [@vazsonyi1999door],
of the type we will do below.

To simulate a trial of this problem, we need to select a door at random to
house the car, and another door at random, to be the door the contestant
chooses.  We number the doors 1, 2 and 3.   Now we need two random choices
from the options 1, 2 or 3, one for the door with the car, the other for the
contestant door.  To chose a door for the car, we could throw a die, and chose
door 1 if the die shows 1 or 4, door 2 if the die shows 2 or 5, and door 3 for
3 or 6.  Then we throw the die again to chose the contestant door.

But throwing dice is a little boring; we have to find the die, then throw it
many times, and record the results.   Instead we can ask the computer to chose
the doors at random.

```{r echo=FALSE, eval=TRUE}
n_trials <- 25
```

For this simulation, let us do `r n_trials` trials.  We ask the computer to
create two sets of `r n_trials` random numbers from 1 through 3. The first set
is the door with the car behind it ("Car door").  The second set have the door
that the contestant chose at random ("Our door").   We put these in a table,
and make some new, empty columns to fill in later.  The first new column is
"Monty opens".  In due course, we will use this column to record the door that
Monty Hall will open on this trial.  The last two columns express the outcome.
The first is "Stay wins".  This has "Yes" if we win on this trial by sticking
to our original choice of door, and "No" otherwise.  The last column is
"Switch wins". This has "Yes" if we win by switching doors, and "No"
otherwise. See table @tbl-montyblank).

```{python echo=FALSE, eval=TRUE}
# Need Python for random numbers that are predictable across platforms.
import numpy as np
import pandas as pd

# Seed chosen such that it generates [3, 3] then [3, 1]
monty_rng = np.random.default_rng(2037)
n_trials = int(r.n_trials)
random_matrix = monty_rng.integers(1, 4, size=(n_trials, 2))
# We need these rows for the example.
assert np.all(random_matrix[:2] == [[3, 3], [3, 1]])
df = pd.DataFrame(random_matrix)
df.columns = ('Car door', 'Our door')
# Set the columns to fill in later.
# It would be more efficient to use `df.assign` here, but less readable.
df['Monty opens'] = ''
df['Stay wins'] = ''
df['Switch wins'] = ''
```

```{r montyblank, echo=FALSE, eval=TRUE}
blank_df <- tibble::as_tibble(py$df)
knitr::kable(blank_df,
  booktabs = TRUE,
  row.names = TRUE,
  caption = sprintf('%d simulations of the Monty Hall problem
                    {#tbl-montyblank}', n_trials)
)
```

```{r echo=FALSE, eval=TRUE}
# Do the calculation
fdf <- blank_df
# Convert Monty opens column to integer, for car door number.
fdf['Monty opens'] <- as.integer(NA)
# Cycle over each row in the original data frame.
for (i in 1:dim(fdf)[1]) {
    car_door <- fdf[i, 'Car door']
    our_door <- fdf[i, 'Our door']
    # Remove our door from consideration.  There are two doors remaining.
    remaining_doors <- setdiff(1:3, our_door)
    if (our_door == car_door) {   # Our door does match car door.
        fdf[i, 'Stay wins'] <- 'Yes'
        fdf[i, 'Switch wins'] <- 'No'
        # Choose one of the remaining (goat) doors at random.
        fdf[i, 'Monty opens'] <- sample(remaining_doors, size=1)
    } else {  # our door did not match.
        fdf[i, 'Stay wins'] <- 'No'
        # Monty must open the remaining door that isn't the car door.
        fdf[i, 'Monty opens'] <- setdiff(remaining_doors, car_door)
        # The only one left is the car door.
        fdf[i, 'Switch wins'] <- 'Yes'
    }
}
```

In the first trial in @tbl-montyblank), the computer selected door 3 for
car, and door 3 for the contestant.  Now Monty must open a door, and he cannot
open our door (door 3) so he has the choice of opening door 1 or door 2; he
chooses randomly, and opens door 2.  On this trial, we win if we stay with our
original choice, and we lose if we change to the remaining door, door 1.

Now we go the second trial.  The computer chose door 3 for the car, and door 1 for our choice.  Monty cannot choose our door (door 1) or the door with the car behind it (door 3), so he must open door 2.   Now if we stay with our original choice, we lose, but if we switch, we win.

You may want to print out table @tbl-montyblank, and fill out the blank
columns, to work through the logic.

After doing a few more trials, and some reflection, you may see that there are
two different situations here: the situation when our *initial guess was
right*, and the situation where our *initial guess was wrong*.   When our
initial guess was right, we win by staying with our original choice, but when
it was wrong, we always win by switching.   The chance of our *initial guess*
being correct is 1/3 (one door out of three).  So the chances of winning by
staying are 1/3, and the chances of winning by switching are 2/3.  But
remember, you don't need to follow this logic to get the right answer.  As you
will see below, the resampling simulation shows us that the Switch strategy
wins.

Table @tbl-montyfull is a version of table @tbl-montyblank for
which we have filled in the blank columns using the logic above.

```{r montyfull, echo=FALSE, eval=TRUE}
knitr::kable(fdf,
  booktabs = TRUE,
  row.names = TRUE,
  caption = sprintf('%d simulations of the Monty Hall problem, filled out
  {#tbl-montyfull}', n_trials)
)
```

The proportion of times "Stay" wins in these `r n_trials` trials is
`r sum(fdf['Stay wins'] == 'Yes') / n_trials`.
The proportion of times "Switch" wins is
`r sum(fdf['Switch wins'] == 'Yes') / n_trials`; the Switch strategy wins about twice as often as the Stay strategy.

## Monty Hall with {{< var lang >}}

Now you have seen what the results might look like for a physical simulation, you can exercise some of your newly-strengthened {{< var lang >}} muscles to do the simulation with code.

::: {.notebook name="monty_hall" title="The Monty Hall problem"}

::: nb-only
Here we do a {{< var lang >}} simulation of the Monty Hall problem.
:::

```{python opts.label="py_ed"}
import numpy as np
rnd = np.random.default_rng()
```

The Monty Hall problem has a slightly complicated structure, so we will start
by looking at the procedure for one trial.  When we have that clear, we will
put that procedure into a `for` loop for the simulation.

Let's start with some variables.  Let's call the door I choose `my_door`.

We choose that door at random from a sequence of all possible doors.  Call the
doors 1, 2 and 3 from left to right.

```{python}
# List of doors to chose from.
doors = [1, 2, 3]

# We choose one door at random.
my_door = rnd.choice(doors)

# Show the result
my_door
```

```{r}
# Vector of doors to chose from.
doors = c(1, 2, 3)

# We choose one door at random.
my_door <- sample(doors, size=1)

# Show the result
my_door
```

We choose one of the doors to be the door with the car behind it:

```{python}
# One door at random has the car behind it.
car_door = rnd.choice(doors)

# Show the result
car_door
```

```{r}
# One door at random has the car behind it.
car_door <- sample(doors, size=1)

# Show the result
car_door
```

Now we need to decide which door Monty will open.

By our set up, Monty cannot open our door (`my_door`).  By the set up, he has
not opened (and cannot open) the door with the car behind it (`car_door`).

`my_door` and `car_door` might be the same.

So, to get Monty's choices, we want to take all doors (`doors`) and remove
`my_door` and `car_door`.  That leaves the door or doors Monty can open.

Here are the doors Monty cannot open.  Remember, a third of the time `my_door` and `car_door` will be the same, so we will include the same door twice, as doors Monty can't open.

```{python}
cant_open = [my_door, car_door]
cant_open
```

```{r}
cant_open = c(my_door, car_door)
cant_open
```

We want to find the remaining doors from `doors` after removing the doors named in `cant_open`.

{{< var np_or_r >}} has a good function for this, called
[`setdiff`]{.r}[`np.setdiff1d`]{.python}.  It calculates the *set difference*
between two sequences, such as {{< var array >}}s.

The set difference between two sequences is the members that *are* in the first
sequence, but are *not* in the second sequence.  Here are a few examples of
this set difference function in {{< var np_or_r >}}.

::: python

Notice that we are using *lists* as the input (first and second) sequences
here.  We can use lists or arrays or any other type of sequence in Python.
Numpy functions like `np.setdiff1d` always *return* an array.

:::

```{python}
# Members in [1, 2, 3] that are *not* in [1]
# 1, 2, 3, removing 1
np.setdiff1d([1, 2, 3], [1])
```

```{python}
# Members in [1, 2, 3] that are *not* in [2, 3]
# 1, 2, 3, removing 2 and 3
np.setdiff1d([1, 2, 3], [2, 3])
```

```{python}
# Members in [1, 2, 3] that are *not* in [2, 2]
# 1, 2, 3, removing 2 and 2 again.
np.setdiff1d([1, 2, 3], [2, 2])
```

```{r}
# Members in c(1, 2, 3) that are *not* in c(1)
# 1, 2, 3, removing 1
setdiff(c(1, 2, 3), c(1))
```

```{r}
# Members in c(1, 2, 3) that are *not* in c(2, 3)
# 1, 2, 3, removing 2 and 3
setdiff(c(1, 2, 3), c(2, 3))
```

```{r}
# Members in c(1, 2, 3) that are *not* in c(2, 2)
# 1, 2, 3, removing 2 and 2 again.
setdiff(c(1, 2, 3), c(2, 2))
```

This logic allows us to choose the doors Monty can open:

```{python}
montys_choices = np.setdiff1d(doors, [my_door, car_door])
montys_choices
```

```{r}
montys_choices <- setdiff(doors, c(my_door, car_door))
montys_choices
```

Notice that `montys_choices` will only have one element left when `my_door` and
`car_door` were different, but it will have two elements if `my_door` and
`car_door` were the same.

Let's play out those two cases:

```{python}
my_door = 1  # For example.
car_door = 2  # For example.
# Monty can only choose door 3 now.
montys_choices = np.setdiff1d(doors, [my_door, car_door])
montys_choices
```

```{python}
my_door = 1  # For example.
car_door = 1  # For example.
# Monty can choose either door 2 or door 3.
montys_choices = np.setdiff1d(doors, [my_door, car_door])
montys_choices
```

```{r}
my_door <- 1  # For example.
car_door <- 2  # For example.
# Monty can only choose door 3 now.
montys_choices <- setdiff(doors, c(my_door, car_door))
montys_choices
```

```{r}
my_door <- 1  # For example.
car_door <- 1  # For example.
# Monty can choose either door 2 or door 3.
montys_choices <- setdiff(doors, c(my_door, car_door))
montys_choices
```

If Monty can only choose one door, we'll take that.  Otherwise we'll chose a
door at random from the two doors available.

```{python}
if len(montys_choices) == 1:  # Only one door available.
    montys_door = montys_choices[0]  # Take the first (of 1!).
else:  # Two doors to choose from:
    # Choose at random
    montys_door = rnd.choice(montys_choices)
montys_door
```

```{r}
if (length(montys_choices) == 1) {  # Only one door available.
    montys_door <- montys_choices[1]  # Take the first (of 1!).
} else {  # Two doors to choose from:
    # Choose at random
    montys_door <- sample(montys_choices, size=1)
}
montys_door
```

Now we know Monty's door, we can identify the other door, by removing our door,
and Monty's door, from the available options:

```{python}
remaining_doors = np.setdiff1d(doors, [my_door, montys_door])
# There is only one remaining door, take that.
other_door = remaining_doors[0]
other_door
```

```{r}
remaining_doors <- setdiff(doors, c(my_door, montys_door))
# There is only one remaining door, take that.
other_door <- remaining_doors[1]
other_door
```

The logic above gives us the full procedure for one trial.

```{python}
my_door = rnd.choice(doors)
car_door = rnd.choice(doors)
# Which door will Monty open?
montys_choices  = np.setdiff1d(doors, [my_door, car_door])
# Choose Monty's door from the remaining options.
if len(montys_choices) == 1:  # At least one door remains.
    montys_door = montys_choices[0]
else:  # There must be two doors to choose from.
    # Choose one of the doors at random.
    montys_door = rnd.choice(montys_choices)
# Now find the door we'll open if we switch.
remaining_doors = np.setdiff1d(doors, [my_door, montys_door])
# There is only one door left.
other_door = remaining_doors[0]
# Calculate the result of this trial.
if my_door == car_door:
    stay_wins = True
if other_door == car_door:
    switch_wins = True
```

```{r}
my_door <- sample(doors, size=1)
car_door <- sample(doors, size=1)
# Which door will Monty open?
montys_choices <- setdiff(doors, c(my_door, car_door))
# Choose Monty's door from the remaining options.
if (length(montys_choices) == 1) {  # At least one door remains.
    # There must be at least one remaining door.
    montys_door <- montys_choices[1]
} else {  # There must be two doors to choose from.
    # Choose one of the doors at random.
    montys_door <- sample(montys_choices, size=1)
}
# Now find the door we'll open if we switch.
# There is only one door left.
remaining_doors <- setdiff(doors, c(my_door, montys_door))
other_door <- remaining_doors[1]
# Calculate the result of this trial.
if (my_door == car_door) {
    stay_wins <- TRUE
}
if (other_door == car_door) {
    switch_wins <- TRUE
}
```

All that remains is to put that trial procedure into a loop, and collect the results are we repeat the procedure many times.

```{python}
# Arrays to store the results for each trial.
stay_wins = np.repeat([False], 10000)
switch_wins = np.repeat([False], 10000)

# A list of doors to chose from.
doors = [1, 2, 3]

for i in range(10000):
    my_door = rnd.choice(doors)
    car_door = rnd.choice(doors)
    # Which door will Monty open?
    montys_choices  = np.setdiff1d(doors, [my_door, car_door])
    # Choose Monty's door from the remaining options.
    if len(montys_choices) == 1:  # At least one door remains.
        montys_door = montys_choices[0]
    else:  # There must be two doors to choose from.
        # Choose one of the doors at random.
        montys_door = rnd.choice(montys_choices)
    # Now find the door we'll open if we switch.
    remaining_doors = np.setdiff1d(doors, [my_door, montys_door])
    # There is only one door left.
    other_door = remaining_doors[0]
    # Calculate the result of this trial.
    if my_door == car_door:
        stay_wins[i] = True
    if other_door == car_door:
        switch_wins[i] = True

p_for_stay = np.sum(stay_wins) / 10000
p_for_switch = np.sum(switch_wins) / 10000

print('p for stay:', p_for_stay)
print('p for switch:', p_for_switch)
```

```{r}
# Vectors to store the results for each trial.
stay_wins <- rep(FALSE, 10000)
switch_wins <- rep(FALSE, 10000)

# Doors to chose from.
doors <- c(1, 2, 3)

for (i in 1:10000) {
    my_door <- sample(doors, size=1)
    car_door <- sample(doors, size=1)
    # Which door will Monty open?
    montys_choices <- setdiff(doors, c(my_door, car_door))
    # Choose Monty's door from the remaining options.
    if (length(montys_choices) == 1) {  # At least one door remains.
        # There must be at least one remaining door.
        montys_door <- montys_choices[1]
    } else {  # There must be two doors to choose from.
        # Choose one of the doors at random.
        montys_door <- sample(montys_choices, size=1)
    }
    # Now find the door we'll open if we switch.
    # There is only one door left.
    remaining_doors <- setdiff(doors, c(my_door, montys_door))
    other_door <- remaining_doors[1]
    # Calculate the result of this trial.
    if (my_door == car_door) {
        stay_wins[i] <- TRUE
    }
    if (other_door == car_door) {
        switch_wins[i] <- TRUE
    }
}

p_for_stay <- sum(stay_wins) / 10000
p_for_switch <- sum(switch_wins) / 10000

message('p for stay: ', p_for_stay)
message('p for switch: ', p_for_switch)
```

We can also follow the same strategy as we used for the two-ships problem in
@sec-ships-booleans.

Here we do not calculate the trial results (`stay_wins`, `switch_wins`) in each
trial.  Instead, we store the *doors* for each trial, and then use Boolean {{<
var array >}}s to calculate the results for all trials, at the end.

```{python}
# Instead of storing the trial results, we store the doors for each trial.
my_doors = np.zeros(10000)
car_doors = np.zeros(10000)
other_doors = np.zeros(10000)

doors = [1, 2, 3]

for i in range(10000):
    my_door = rnd.choice(doors)
    car_door = rnd.choice(doors)
    # Which door will Monty open?
    montys_choices  = np.setdiff1d(doors, [my_door, car_door])
    # Choose Monty's door from the remaining options.
    if len(montys_choices) == 1:  # At least one door remains.
        montys_door = montys_choices[0]
    else:  # There must be two doors to choose from.
        # Choose one of the doors at random.
        montys_door = rnd.choice(montys_choices)
    # Now find the door we'll open if we switch.
    remaining_doors = np.setdiff1d(doors, [my_door, montys_door])
    # There is only one door left.
    other_door = remaining_doors[0]

    # Store the doors we chose.
    my_doors[i] = my_door
    car_doors[i] = car_door
    other_doors[i] = other_door

# Now - at the end of all the trials, we use Boolean arrays to calculate the
# results.
stay_wins = my_doors == car_doors
switch_wins = other_doors == car_doors

p_for_stay = np.sum(stay_wins) / 10000
p_for_switch = np.sum(switch_wins) / 10000

print('p for stay:', p_for_stay)
print('p for switch:', p_for_switch)
```

```{r}
# Instead of storing the trial results, we store the doors for each trial.
my_doors <- numeric(10000)
car_doors <- numeric(10000)
other_doors <- numeric(10000)

# Doors to chose from.
doors <- c(1, 2, 3)

for (i in 1:10000) {
    my_door <- sample(doors, size=1)
    car_door <- sample(doors, size=1)
    # Which door will Monty open?
    montys_choices <- setdiff(doors, c(my_door, car_door))
    # Choose Monty's door from the remaining options.
    if (length(montys_choices) == 1) {  # At least one door remains.
        # There must be at least one remaining door.
        montys_door <- montys_choices[1]
    } else {  # There must be two doors to choose from.
        # Choose one of the doors at random.
        montys_door <- sample(montys_choices, size=1)
    }
    # Now find the door we'll open if we switch.
    # There is only one door left.
    remaining_doors <- setdiff(doors, c(my_door, montys_door))
    other_door <- remaining_doors[1]

    # Store the doors we chose.
    my_doors[i] <- my_door
    car_doors[i] <- car_door
    other_doors[i] <- other_door
}

# Now - at the end of all the trials, we use Boolean vectors to calculate the
# results.
stay_wins <- my_doors == car_doors
switch_wins <- other_doors == car_doors

p_for_stay <- sum(stay_wins) / 10000
p_for_switch <- sum(switch_wins) / 10000

message('p for stay: ', p_for_stay)
message('p for switch: ', p_for_switch)
```

### Insight from the Monty Hall simulation

The code simulation gives us an estimate of the right answer, but it also forces us to set out the exact mechanics of the problem.   For example, by looking at the code, we see that we can calculate "stay_wins" with this code alone:

```{python}
# Just choose my door and the car door for each trial.
my_doors = np.zeros(10000)
car_doors = np.zeros(10000)
doors = [1, 2, 3]

for i in range(10000):
    my_doors[i] = rnd.choice(doors)
    car_doors[i] = rnd.choice(doors)

# Calculate whether I won by staying.
stay_wins = my_doors == car_doors
p_for_stay = np.sum(stay_wins) / 10000

print('p for stay:', p_for_stay)
```

```{r}
# Just choose my door and the car door for each trial.
my_doors <- numeric(10000)
car_doors <- numeric(10000)
doors <- c(1, 2, 3)

for (i in 1:10000) {
    my_doors[i] <- sample(doors, size=1)
    car_doors[i] <- sample(doors, size=1)
}

# Calculate whether I won by staying.
stay_wins <- my_doors == car_doors
p_for_stay <- sum(stay_wins) / 10000

message('p for stay: ', p_for_stay)
```

This calculation, on its own, tells us the answer, but it also points to
another insight â€” whatever Monty does with the doors, it doesn't change the
probability that our *initial guess* is right, and that must be 1 in 3 (0.333).
If the probability of `stay_win` is 1 in 3, and we only have one other door to
switch to, the probability of winning after switching must be 2 in 3 (0.666).

### Simulation and a variant of Monty Hall

You have seen that you can avoid the silly mistakes that many of us make with probability â€” by asking the computer to tell you the result *before* you start to reason from first principles.

As an example, consider the following variant of the Monty Hall problem.

The set up to the problem has us choosing a door (`my_door` above), and then
Monty opens one of the other two doors.

Sometimes (in fact, 2/3 of the time) there is a car behind one of Monty's
doors, and we've obliged him to open the *other* door, and his choice is
forced.

When his choice was not forced, we had Monty choose the door at random.

For example, let us say we chose door 1.

Let us say that the car is also under door 1.

Monty has the option of choosing door 2 or door 3, and he chooses randomly
between them.

```{python}
my_door = 1  # We chose door 1 at random.
car_door = 1  # This trial, by chance, the car door is 1.
# Monty is left with doors 2 and 3 to choose from.
montys_choices  = np.setdiff1d(doors, [my_door, car_door])
# He chooses randomly.
montys_door = rnd.choice(montys_choices)
# Show the result
montys_door
```

```{r}
my_door <- 1  # We chose door 1 at random.
car_door <- 1  # This trial, by chance, the car door is 1.
# Monty is left with doors 2 and 3 to choose from.
montys_choices <- setdiff(doors, c(my_door, car_door))
# He chooses randomly.
montys_door <- sample(montys_choices, size=1)
# Show the result
montys_door
```

Now â€” let us say we happen to know that Monty is rather lazy, and he will
always choose the left-most (lower-numbered) door of the two options.

In the previous example, Monty had the option of choosing door 2 and 3.  In
this new scenario, we know that he will always choose door 2 (the left-most
door).

```{python}
my_door = 1  # We chose door 1 at random.
car_door = 1  # This trial, by chance, the car door is 1.
# Monty is left with doors 2 and 3 to choose from.
montys_choices  = np.setdiff1d(doors, [my_door, car_door])
# He chooses the left-most door, always.
montys_door = montys_choices[0]
# Show the result
montys_door
```

```{r}
my_door <- 1  # We chose door 1 at random.
car_door <- 1  # This trial, by chance, the car door is 1.
# Monty is left with doors 2 and 3 to choose from.
montys_choices <- setdiff(doors, c(my_door, car_door))
# He chooses the left-most door, always.
montys_door <- montys_choices[1]
# Show the result
montys_door
```

It feels as if we have more information about where the car is, when we know this.
Consider the situation where we have chosen door 1, and Monty opens door 3.  We
know that he would have preferred to open door 2, if he was allowed.  We
therefore know he wasn't allowed to open door 2, and that means the car is
definitely under door 2.

```{python}
my_door = 1  # We chose door 1 at random.
car_door = 2  # This trial, by chance, the car door under door 2.
# Monty is left with door 3 only to choose from.
montys_choices  = np.setdiff1d(doors, [my_door, car_door])
# He chooses the left-most door, always.  But in this case, the left-most
# available door is 3 (he can't choose 2, it is the car_door).
# Notice the doors were in order, so the left-most door is the first door
# in the array.
montys_door = montys_choices[0]
# Show the result
montys_door
```

```{r}
my_door <- 1  # We chose door 1 at random.
car_door <- 1  # This trial, by chance, the car door is 1.
# Monty is left with door 3 only to choose from.
montys_choices <- setdiff(doors, c(my_door, car_door))
# He chooses the left-most door, always.  But in this case, the left-most
# available door is 3 (he can't choose 2, it is the car_door).
# Notice the doors were in order, so the left-most door is the first door
# in the vector.
montys_door <- montys_choices[1]
# Show the result
montys_door
```

To take that into account, we might try a different strategy.  We will stick to
our own choice if Monty has chosen the left-most of the two doors he had
available to him, because he might have chosen that door because there was a
car underneath the other door, or because there was a car under neither, but he
preferred the left door.  But, if Monty chooses the right-most of the two-doors
available to him, we will switch from our own choice to the other (unopened)
door, because we can be sure that the car is under the other (unopened) door.

Call this the "switch if Monty chooses right door" strategy, or "switch if
right" for short.

Can you see quickly whether this will be better than the "always stay"
strategy?  Will it be better than the "always switch" strategy?   Take a moment
to think it through, and write down your answers.  

If you can quickly see the answer to both questions â€” well done â€” but, are you
sure you are right?

We can test by simulation.

For our test of the "switch is right" strategy, we can tell if one door is
to the right of another door by comparison; higher numbers mean further to the
right: 2 is right of 1, and 3 is right of 2.

```{python}
# Door 3 is right of door 1.
3 > 1
```

```{r}
# Door 3 is right of door 1.
3 > 1
```

```{python}
# A test of the switch-if-right strategy.
# The car doors.
car_doors = np.zeros(10000)
# The door we chose using the strategy.
strategy_doors = np.zeros(10000)

doors = [1, 2, 3]

for i in range(10000):
    my_door = rnd.choice(doors)
    car_door = rnd.choice(doors)
    # Which door will Monty open?
    montys_choices  = np.setdiff1d(doors, [my_door, car_door])
    # Choose Monty's door from the remaining options.
    # This time, he always prefers the left door.
    montys_door = montys_choices[0]
    # Now find the door we'll open if we switch.
    remaining_doors = np.setdiff1d(doors, [my_door, montys_door])
    # There is only one door remaining - but is Monty's door
    # to the right of this one?  Then Monty had to shift.
    other_door = remaining_doors[0]
    if montys_door > other_door:
        # Monty's door was the right-hand door, the car is under the other one.
        strategy_doors[i] = other_door
    else:  # We stick with the door we first thought of.
        strategy_doors[i] = my_door
    # Store the car door for this trial.
    car_doors[i] = car_door

strategy_wins = strategy_doors == car_doors

p_for_strategy = np.sum(strategy_wins) / 10000

print('p for strategy:', p_for_strategy)
```

```{r}
# A test of the switch-if-right strategy.
# The car doors.
car_doors <- numeric(10000)
# The door we chose using the strategy.
strategy_doors <- numeric(10000)

doors <- c(1, 2, 3)

for (i in 1:10000) {
    my_door <- sample(doors, size=1)
    car_door <- sample(doors, size=1)
    # Which door will Monty open?
    montys_choices <- setdiff(doors, c(my_door, car_door))
    # Choose Monty's door from the remaining options.
    # This time, he always prefers the left door.
    montys_door <- montys_choices[1]
    # Now find the door we'll open if we switch.
    remaining_doors <- setdiff(doors, c(my_door, montys_door))
    # There is only one door remaining - but is Monty's door
    # to the right of this one?  Then Monty had to shift.
    other_door <- remaining_doors[1]
    if (montys_door > other_door) {
        # Monty's door was the right-hand door, the car is under the other one.
        strategy_doors[i] <- other_door
    } else {  # We stick with the door we first thought of.
        strategy_doors[i] <- my_door
    }
    # Store the car door for this trial.
    car_doors[i] <- car_door
}

strategy_wins <- strategy_doors == car_doors

p_for_strategy <- sum(strategy_wins) / 10000

message('p for strategy: ', p_for_strategy)
```

We find that the "switch-if-right" has around the same chance of success as the
"always-switch" strategy â€” of about 66.6%, or 2 in 3. Were your initial answers
right?  Now you've seen the result, can you see why it should be so?  It may
not be obvious â€” the Monty Hall problem is deceptively difficult.   But our
case here is that the simulation first gives you an estimate of the correct
answer, and then, gives you a good basis for thinking more about the problem.  That is:

* simulation is useful for estimation and
* simulation is useful for reflection.

:::

## Why use simulation?

Doing these simulations has two large benefits.   First, it gives us the right answer, saving us from making a mistake.  Second, the process of simulation forces us to think about how the problem works.  This can give us better understanding, and make it easier to reason about the solution.

We will soon see that these same advantages also apply to reasoning about
statistics.
