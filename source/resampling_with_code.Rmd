---
jupyter:
  jupytext:
    metadata_filter:
      notebook:
        additional: all
        excluded:
        - language_info
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
resampling_with:
    ed2_fname: null
---

```{r setup, include=FALSE}
source("_common.R")
```

# Resampling with code

Chapter @sec-resampling-method used simulation and resampling from
tables of random numbers, dice, and coins.  Making random choices in this way
can make it easier to understand the process, but of course, physical methods
of making random outcomes can be slow and boring.

We saw that short computer programs can do a huge number of resampling
trials in a few seconds.  The flexibility of a programming language makes it
possible to simulate many different outcomes and tests.

Programs can build up tables of random numbers, and do simple
tasks like counting the number of values in a row or taking
proportions.  With these simple tools, we can simulate many problems
in probability and statistics.

In this chapter, we will again model a problem using
{{< var lang >}},
but this time we will explain how the code works in more detail.

By the end of the chapter, you will be able to understand better how
{{< var lang >}}
can build up complete simulations using random numbers, and how the
programming instructions relate to the tasks we need to do.

We have already emphasized that *statistics* is a way of drawing conclusions
about data from the real world, in the presence of random variation, and
*probability* is the way of reasoning about random variation.  This chapter
introduces our first *statistical* problem, where we use probability to draw
conclusions about some important data — about a potential cure for a type of
cancer.  We will not make much of the distinction between probability and
statistics here, but we will come back to it several times in later chapters.

<!---
*TODO* - Check we have discussed this before.
-->

## A new treatment for Burkitt lymphoma

[Burkitt lymphoma](https://en.wikipedia.org/wiki/Burkitt_lymphoma) is a rather
unusual cancer of the lymphatic system.  The lymphatic system is a vein-like
network throughout the body that is involved in the immune reaction to
disease. In developed countries, with standard treatment, the cure rate for
Burkitt lymphoma is about 90%.

In 2006, researchers at the US National Cancer Institute (NCI), tested a new
treatment for Burkitt lymphoma [@dunleavy2006burkitt]. They gave their new
treatment to 17 patients, and found that all 17 patients were "cured" —
meaning that the disease had not progressed in any of the 17 patients, in more
than two years of follow-up.

Here is where we put on our statistical hat and ask ourselves the following
question — *how surprised are we that the NCI researchers saw their 17 out of
17 result?*

At this stage you might and should ask, what could we possibly mean by
"surprised"?  That is a good and important question, and we will discuss that
much more in the chapters to come.  For now, please bear with us as we do a thought experiment.

Let us forget the 17 out of 17 result of the NCI study for a moment. Imagine
that there is another hospital, called Saint Hypothetical General (SHG), just
down the road from the NCI, that was also treating 17 patients with Burkitt
lymphoma, but they were not using the NCI treatment, they were using the
standard treatment.

We know from the background information above, that each patient given the
standard treatment has a 90% chance of cure.  Given that 90% rate, what is the
chance that 17 out of 17 of the Hypothetical group will be cured?

You may notice that this question about the Hypothetical group is 
similar to the problem of the 20 ambulances in Chapter @sec-resampling-method.
In that problem, we were interested to know how likely it was that 3 or more
of 20 ambulances would be out of action on any one day, given that each
ambulance had a 10% chance of being out of action.  Here we would like to know
the chances that all 17 patients would be cured, given that each patient has a 90% chance of being cured.

## A physical model of the hypothetical hospital

As in the ambulance example, we could make a physical model of chance in
this world.  For example, to simulate whether a given patient is cured or not
by a 90% effective treatment, we could throw a ten sided die and record the
result.  We could say, arbitrarily, that a result of 0 means "not cured", and
all the numbers 1 through 9 mean "cured" (typical 10-sided dice have sides
numbered 0 through 9).

We could roll 17 dice to simulate one "trial" in this random world.  For each
trial, we record the number of dice that show numbers 1 through 9 (and not
0).  This will be a number between 0 and 17, and it is the number of patients
"cured" in our simulated trial.

Here is the result of one such trial we did with a set of 17 10-sided dice we happened to have near to hand:

![One roll of 17 10-sided dice](images/17_d10s.png)

In this case there are four 0s, and the rest are from 1 through 9, so there
were 13 out of 17 not-zero numbers, and therefore, 13 out of 17 "patients" who
were "cured" in this simulated trial.

<!---
Adapt text above to picture.
-->

We could repeat this simulated trial procedure 100 times, and we would then
have 100 counts of the not-zero numbers. Each of the 100 counts would be the
number of patients cured in that trial.  We can ask how many of these 100
counts were equal to 17.  This will give us an estimate of the probability we
would see 17 out of 17 patients cured, given that any one patient has a 90%
chance of cure.  For example, say we saw 15 out of 100 counts were equal to
17.  That would give us an estimate of 15 / 100 or 0.15 or 15%, for the
probability we would see 17 out of 17 patients cured.

So, if Saint Hypothetical General did see 17 out of 17 patients cured with the
standard treatment, they would be a little surprised, because they would only
expect to see that happen 15% of the time.  But they would not be *very*
surprised — they do expect to see that result more than one time in 10.

## Simulating the physical model with the computer

We can use the computer to do something very similar to rolling 17 10-sided
dice, by asking the computer for 17 random whole numbers from 0 through 9.

:::{.callout-note}
## Whole numbers

A whole number is a number that is not negative, and does not have fractional
part (does not have anything after a decimal point).  0 and 1 and 2 and 3 are
whole numbers, but -1 and $\frac{3}{5}$ and 11.3 are not. The whole numbers
from 0 through 9 are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
:::

:::{.callout-note}
## What do we mean by random?

We said above that we want 17 *random* whole numbers from 0 through 9.  What do
we mean by *random* here?  We will talk about this much more in the section
@sec-what-is-chance}.  For now let us say only that random means we cannot do
anything to predict the number.  When we get each new number, we know it will
be some number from 0 through 9, but we cannot do anything more to predict
which number this will be.  There is an equal chance that the new number will
be any one of the numbers 0 through 9 — there is a 10% chance we will get a
0, a 10% chance of a 1, and so on.
:::

::: python
We will be asking the computer to generate many random numbers.  So, before we
start, we again import NumPy and get its *random number generator*:

```{python, opts.label="py_ed"}
import numpy as np

# Ask for NumPy's default random number generator and name
# it `rnd`.  `rnd` is short for "random".
rnd = np.random.default_rng()
```
:::

We prepare the sequence of numbers that we want [NumPy]{.python}[R]{.r} to
select from:

```{python, opts.label="py_ed"}
# Make sequence of numbers, store with the name "some_numbers".
some_numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```{r, opts.label="r_ed"}
# Make sequence of numbers, store with the name "some_numbers".
some_numbers <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```

We can use [`rnd`]{.python}[the `sample` command]{.r} to select a single value
*at random* from the sequence of numbers in `some_numbers`.

We can also ask `sample` to select 17 numbers at random from the sequence.  To

```{python, opts.label="py_ed"}
rnd.choice(some_numbers)
```

```{r, opts.label="r_ed"}
sample(some_numbers)
```

We can also ask [Numpy]{.python}[R]{.r} to select 17 numbers at random from the
sequence of `some_numbers`.

:::python
To do this, we add the `size=17` instruction to the code.

```{python, opts.label="py_ed"}
# Get 17 (size=17) values from the *some_numbers* sequence.
# Store the 17 numbers with the name "a"
a = rnd.choice(some_numbers, size=17)
a
```
:::

::: r
To do this, we specify the number 17, and add an extra instruction
`replace=TRUE`.  `replace=TRUE` tells R to sample `some_numbers` *with
replacement*.  We will soon explain more about what this means, but for now,
please take our word for it that `replace=TRUE` gives use the same effect as
rolling the 10-sided dice.

```{r, opts.label="r_ed"}
# Get 17 (size=17) values from the *some_numbers* sequence.
# Store the 17 numbers with the name "a"
a <- sample(some_numbers, 17, replace=TRUE)
```
:::

::: todo
Section on resampling with and without replacement in later chapter.
:::

## More about [arrays]{.python}[vectors]{.r}

Now we take a closer look at the thing that came back from the
[`rnd.choice`]{.python}[`sample`]{.r}
command.

```{python, opts.label="py_ed"}
# Show the value stored in "a".
a
```

```{r, opts.label="r_ed"}
# Show the value stored in "a".
a
```

Notice that `a` contains 17 numbers.  In fact, `a` is a *container*, where the
container holds 17 numbers.  In [Python]{.python}[R]{.r}, this container for numbers is called [an *array*]{.python}[a *vector*]{.r}.  We will use these containers all the time to store sequences of numbers.

::: todo

* Getting values with indexing
* Setting values with indexing
* Making a new vector of zeros.
:::

:::{.callout-note}
## Array data types

Since we will be working with NumPy arrays a lot, it is worth knowing more about them.

A NumPy array is a container that stores many elements of the same type.  With type, we mean things like integers (-2, -1, 0, 1, 2, 3, etc.), floating point numbers (1.5, 3.3, etc.), objects like strings ("hello", "world", etc.), and boolean values (True or False).

Often, we will create a NumPy array to store our results before we begin.  We do this with the "zeros" command, which makes an empty array of a given size:

```{python, opts.label="py_ed"}
x = np.zeros(3, dtype=int)
y = np.zeros(3, dtype=float)
z = np.zeros(3, dtype=bool)
print(x, y, z)
```

We can now assign elements into specific positions:

```{python, opts.label="py_ed"}
x[2] = 5
print(x)
```

We will also be making use of arrays that store strings.  We initialize these arrays as above:

```{python, opts.label="py_ed"}
w = np.zeros(3, dtype=object)
print(w)
```

Note that, by default, NumPy fills these arrays with zeros (integers).  But because the array is set to store *objects*, we can replace those integers with strings:

```{python, opts.label="py_ed"}
w[1] = "hello"
w[2] = "world"
print(w)
```

What happens when we ask NumPy to check whether each element in the array is equal to "world"?  We get the following:

```{python, opts.label="py_ed"}
w == "world"
```

This is a *boolean* array (True or False), telling us the answer to that question.  We often count the number of "True" responses as follows:

```{python, opts.label="py_ed"}
np.count_nonzero(w == "world")
```

(In Python, True is equivalent to 1 and False is equivalent to 0.)
:::

Let us now simulate a single trial, where seventeen patients are treated
with the 90% effective treatment:

```{python, opts.label="py_ed"}
N = 17

# An array of 17 slots in which we stored 'cured' or 'not cured' for
# each patient
cured = np.zeros(N, dtype=object)

for i in range(N):
    # For each of the 17 patients, do the following:

    outcome = rnd.choice(['cured', 'not cured'], p=[0.9, 0.1])

    # Store in the cured array at position i whether this patient
    # was cured or not
    cured[i] = 'cured'

# Count the number of patients cured
number_cured = np.count_nonzero(cured == 'cured')

# Were all 17 patients cured?  This will be True or False
all_cured = (number_cured == N)
```

:::{.callout-note}
## For-loops in Python

We first saw for-loops in Chapter @sec-resampling-method.  We will now dive
into them a bit more deeply.

Imagine a factory robot that slides along a worktable on which several
items have been placed.  It services each of these items, one by one,
until it is done.

So the robot knows *which* item it is operating on, each item is given
a label.

Here is an example:

```{python, opts.label="py_ed"}
for item in ['shoe', 'saddle', 'jacket']:
    print('I am stitching a', item)
```

Here, the robot is working its way through three items: a shoe, a saddle, and a jacket.
As it moves on to each object, it assigns the label ("shoe", "saddle", etc.) to the variable `item`.
The indented block of code under the for is executed for each item, and in this code block `label` can be accessed.
The code above can therefore be unpacked into the following equivalent program:

```{python, opts.label="py_ed"}
item = 'shoe'
print('I am stitching a', item)

item = 'saddle'
print('I am stitching a', item)

item = 'jacket'
print('I am stitching a', item)
```

We used the name `item` here, but any other name would do.
Thus, the following is equivalent:

```{python, opts.label="py_ed"}
for package in ['shoe', 'saddle', 'jacket']:
    print('I am stitching a', package)
```

It is common to use a number as a label in a for loop:

```{python, opts.label="py_ed"}
for i in [0, 1, 2, 3, 4]:
    print('The square of', i, 'is', i * i)
```

When we want to count to a hundred, it becomes laborious to type out the numbers.
For that, Python has a shorthand called `range`:

```{python, opts.label="py_ed"}
for i in range(5):
    print('The square of', i, ' is ', i * i)
```
:::

Here, for each of the 17 patients, we draw 'cured' (90% probable) or 'not cured' (10% probable) from our outcomes.
We could just as easily draw all 17 outcomes at the same time:

```{python, opts.label="py_ed"}
cured = rnd.choice(['cured', 'not cured'], p=[0.9, 0.1], size=17)
number_cured = np.count_nonzero(cured == 'cured')
all_cured = (number_cured == N)
```

Instead of explicitly counting the number of cured patients, we can also use the NumPy `all` command:

```{python, opts.label="py_ed"}
cured = rnd.choice(['cured', 'not cured'], p=[0.9, 0.1], size=17)

# This is True or False
all_cured = np.all(cured == 'cured')
```

The above resembles one trial where 17 patients were treated.  We would like to count, over many trials, how often *all* patients were cured:

```{python, opts.label="py_ed"}
T = 10000

# Array to store trial outcomes in
z = np.zeros(T, dtype=bool)

for i in range(T):
    cured = rnd.choice(['cured', 'not cured'], p=[0.9, 0.1], size=17)
    all_cured = np.all(cured == 'cured')

    z[i] = all_cured

# Determine in how many trials all patients were cured
k = np.count_nonzero(z)

# Convert to a proportion
kk = k / T

print(kk)
```

From this experiment, we see that there is roughly a one-in-six chance that all 17 patients are cured when using a 90% effective treatment.

---

Here is our first
{{< var lang >}}
example program.  Do not expect to
follow all of it straightaway.  For now, read the code below to get an
idea of how it implements the procedure above.  We will be coming back
to the specifics later.

The key to reading code is to think about what the computer will do, when it sees the code.


::: {.notebook name="resampling_with_code"}

A simple place to start is the *comment*.  A comment is a statement that the
computer will *ignore*.   It is text that we put in the program for our
benefit, to explain what is going on to a human reader.

This is an example of a comment:

```{python, opts.label="py_ed"}
# This is a comment. It doesn't have any effect.
```

```{r, opts.label="r_ed"}
# This is a comment. It doesn't have any effect.
```

The comment starts with a hash character `#`.  This character tells the
computer that the rest of the line is a comment, and therefore, that it can
ignore everything on that line that follows the `#`.

::: python

In the next bit of code, we load the *function* `randint` that
produces random numbers.

The code has four lines.  The first and third are comments; the
computer ignores them. The second line loads the NumPy library that we
use in nearly all our examples, and the last line loads the function
to generate random numbers.  After we run this code, we have a
function called `randint`, and a library called `np`.

```{python, opts.label="py_ed"}
# Import the numpy library
import numpy as np
# Get the function to generate random numbers.
from numpy.random import randint
```

:::

To solve the problem, we have to generate some random numbers:

::: python

```{python, opts.label="py_ed"}
a = randint(1, 11, 20)
```

This uses the `randint` *function* to generate random integers (counting numbers) from 1 up to, *but not including*, 11.  Therefore, this command will generate random numbers from 1 through 10.  The 20 in the command tells the function to generate 20 of these numbers.

:::

::: r

```{r, opts.label="r_ed"}
a = sample(1:10, 20, replace=TRUE)
```

This uses the `sample` function to generate random integers (counting numbers)
from 1 through 10.  The 20 in the command tells R to generate 20 of these
numbers.  `replace=TRUE` tells R to sample *with replacement*.

For example, the chances of getting a particular result - such as a 3 - for the
first random number - are 1 in 10, or p= 1/10 = 0.1.  If we resample *with
replacement* then the chances of getting 3 in the second number are unchanged,
at p=0.1.  It is as if we put 10 balls into a bucket, numbered one through ten,
and then selected 20 balls from the bucket; but after we have selected a ball,
we record the number and *replace* it in the bucket, and shake up the bucket
again.

:::

Inasmuch as each ambulance has a 1 in 10 chance of being
defective, we decide arbitrarily that a "1" stands for a defective ambulance,
and the other nine numbers (from "2" to "10") stand for a not-defective
ambulance. The command above orders the computer to store the results of the random
drawing in a location in the computer's memory to which we give a name, in this case `a` (we could have chosen any name such as, for example, `ambulances`).  When we run a statement like the one above, `a` is
a *variable* - the *name* `a` refers to the *value*, which is the sequence of
random numbers the computer created using
[`randint`]{.python}[`sample`]{.r}

We can display the value of the variable `a` by using the `print` function:

```{python, opts.label="py_ed"}
print(a)
```

```{r, opts.label="r_ed"}
print(a)
```

This shows the 20 random values that we got from
[`randint`]{.python}[`sample`]{.r}


The next key element in the core of the program is:

```{python, opts.label="py_ed"}
b = np.count_nonzero(a == 1)
```

```{r, opts.label="r_ed"}
b = sum(a == 1)
```

This command can be broken up into two pieces: the first (`a == 1`)
compares each element in `a` to 1, resulting in a True or False
value. We then proceed to count those values, to determine how many of
the 20 values in `a` are equal to 1. The result of the count will be
somewhere between 0 and 20, the number of ambulances that might be
out-of-order on a given day. The result is then placed in another
location in the computer's memory that we label `b`.

```{python, opts.label="py_ed"}
# Show the value of b
print(b)
```

```{r, opts.label="r_ed"}
# Show the value of b
print(b)
```

Now let us place the commands to generate the random numbers, and count how
many `1`s we get, within a program that solves this problem:

```{python, opts.label="py_ed"}
# Make an array that has 400 elements.
# We will use this to store the counts for our 400 repetitions
results = np.zeros(400)

# Repeat the simulation 400 times
for i in np.arange(400):

    # The indented commands are the procedure for one trial.
    # The computer runs these commands from first to last, for each trial.

    # Generate 20 numbers, each between "1" and "10," and put them in vector a.
    # Each number will represent an ambulance, and we let 1 represent
    # a defective ambulance.
    a = randint(1, 11, 20)

    # Count the number of defective ambulances, and put the result in b.
    b = np.count_nonzero(a == 1)

    # Keep track of each trial's result in "results".
    results[i] = b

    # End this trial, then go back and repeat the process until all 400 trials
    # are complete.

# Now we have finished the 400 trials.

# Determine how many trials resulted in more than 3 ambulances out of order.
bad_day_count = np.count_nonzero(results > 3)

# Convert to a proportion.
bad_day_prop = bad_day_count / 400

# Print the result.
print(bad_day_prop)
```

```{r, opts.label="r_ed"}
# Make an array that has 400 elements.
# We will use this to store the counts for our 400 repetitions
results <- numeric(400)

# Repeat the simulation 400 times
for (i in 1:400) {

    # The commands between the { above and the } below are the procedure for
    # one trial.
    # The computer runs these commands from first to last, for each trial.

    # Generate 20 numbers, each between "1" and "10," and put them in vector a.
    # Each number will represent an ambulance, and we let 1 represent
    # a defective ambulance.
    a <- sample(1:10, 20, replace=TRUE)

    # Count the number of defective ambulances, and put the result in b.
    b <- sum(a == 1)

    # Keep track of each trial's result in "results".
    results[i] <- b

    # End this trial, then go back and repeat the process until all 400 trials
    # are complete.
}

# Now we have finished the 400 trials.

# Determine how many trials resulted in more than 3 ambulances out of order.
bad_day_count <- sum(results > 3)

# Convert to a proportion.
bad_day_prop <- bad_day_count / 400

# Print the result.
print(bad_day_prop)
```

:::

The
[`results[i] = b`]{.python}[`results[i] <- b`]{.r}
statement that follows the
[`b = np.count_nonzero(a == 1)`]{.python}[`b = sum(a == 1)`]{.r}
operation keeps track of the results of each trial, placing the number
of defective ambulances that occur in each trial in a location that we
call "results". This is done in each of the 400 trials that we make, and the
result eventually is a "vector" with 400 numbers in it.  A vector is just
a sequence of numbers.

In order to make 400 repetitions of our experiment --- we could have
decided to make a thousand or some other number of repetitions --- we put
[`for i in np.arange(400):`]{.python}[`for (i in 1:400) {`]{.r}
before the statements that generate the random numbers, count how many of these numbers are 1, representing a defective ambulance, and store this result
of a single trial. Then we complete each repetition "loop" by
[bringing the indentation of the statements back to the left margin]{.python}
[adding a closing `}` bracket]{.r}.

Since our aim is to count the number of days in which more than 3 (4 or more)
defective ambulances occur, we use the
[`bad_day_count = np.count_nonzero(results > 3)`]{.python}
[`bad_day_count = sum(results > 3)`]{.r}
command to count how many times in the 400 days recorded in our results vector
at the end of the 400 trials more than 3 defects occurred, and we place the
result in still another location: `bad_day_count`.

This gives us the total number of days where 4 or more defective ambulances are
seen to occur. Then we divide the number in "bad_day_count" by 400, the number
of trials. Thus we obtain an estimate of the chance, expressed as a probability
between 0 and 1, that 4 or more ambulances will be defective on a given day.
And we store that result in a location that we decide to call `bad_day_prop` so
that it will be there when the computer receives the next command to `print`
that result on the screen.

Can you see how each of the operations that the computer carries out are
analogous to the operations that you yourself executed when you solved this
problem using a labeled coins or a random-number table? This is exactly the
procedure that we will use to solve every problem in probability and statistics
that we must deal with. Either we will use a device such as coins or a random
number table as an analogy for the physical process we are interested in
(ambulances becoming defective, in this case), or we will simulate the analogy
on the computer using the {{< var lang >}} program above.

The program above may not seem simple at first glance, but we think
you will find, over the course of this book, that these programs
become much simpler to understand than the older conventional approach
to such problems that has routinely been taught to students for
decades.
