---
jupyter:
  jupytext:
    metadata_filter:
      notebook:
        additional: all
        excluded:
        - language_info
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
resampling_with:
    ed2_fname: null
---

```{r setup, include=FALSE}
source("_common.R")
```

# Resampling with code

Chapter @sec-resampling-method used simulation and resampling from
tables of random numbers, dice, and coins.  Making random choices in this way
can make it easier to understand the process, but of course, physical methods
of making random outcomes can be slow and boring.

We saw that short computer programs can do a huge number of resampling
trials in a less than a second.  The flexibility of a programming language
makes it possible to simulate many different outcomes and tests.

Programs can build up tables of random numbers, and do basic
tasks like counting the number of values in a row or taking
proportions.  With these simple tools, we can simulate many problems
in probability and statistics.

In this chapter, we will again model a problem using
{{< var lang >}},
but this time we will explain how the code works in more detail.

By the end of the chapter, you will be able to understand better how
{{< var lang >}}
can build up complete simulations using random numbers, and how the programming
instructions relate to the tasks we need to do.

We have already emphasized that *statistics* is a way of drawing conclusions
about data from the real world, in the presence of random variation;
*probability* is the way of reasoning about random variation.  This chapter
introduces our first *statistical* problem, where we use probability to draw
conclusions about some important data — about a potential cure for a type of
cancer.  We will not make much of the distinction between probability and
statistics here, but we will come back to it several times in later chapters.

::: todo
Check we have discussed this before.
:::

## A new treatment for Burkitt lymphoma

[Burkitt lymphoma](https://en.wikipedia.org/wiki/Burkitt_lymphoma) is an
unusual cancer of the lymphatic system.  The lymphatic system is a vein-like
network throughout the body that is involved in the immune reaction to disease.
In developed countries, with standard treatment, the cure rate for Burkitt
lymphoma is about 90%.

In 2006, researchers at the US National Cancer Institute (NCI), tested a new
treatment for Burkitt lymphoma [@dunleavy2006burkitt]. They gave the new
treatment to 17 patients, and found that all 17 patients were doing well after
two years or more of follow up.  By "doing well", we mean that their lymphoma
had not progressed; as a short-hand, we will say that these patients were
"cured", but of course, we do not know what happened to them after this follow
up.

Here is where we put on our statistical hat and ask ourselves the following
question — *how surprised are we that the NCI researchers saw their result of
17 out of 17 patients cured?*

At this stage you might and should ask, what could we possibly mean by
"surprised"?  That is a good and important question, and we will discuss that
much more in the chapters to come.  For now, please bear with us as we do a
thought experiment.

Let us forget the 17 out of 17 result of the NCI study for a moment. Imagine
that there is another hospital, called Saint Hypothetical General (SHG), just
down the road from the NCI, that was also treating 17 patients with Burkitt
lymphoma. Saint Hypothetical were not using the NCI treatment, they were using
the standard treatment.

We already know that each patient given the standard treatment has a 90% chance
of cure.  Given that 90% cure rate, what is the chance that 17 out of 17 of the
Hypothetical group will be cured?

You may notice that this question about the Hypothetical group is similar to
the problem of the 20 ambulances in Chapter @sec-resampling-method. In that
problem, we were interested to know how likely it was that 3 or more of 20
ambulances would be out of action on any one day, given that each ambulance had
a 10% chance of being out of action.  Here we would like to know the chances
that all 17 patients would be cured, given that each patient has a 90% chance
of being cured.

## A physical model of the hypothetical hospital

As in the ambulance example, we could make a physical model of chance in
this world.  For example, to simulate whether a given patient is cured or not
by a 90% effective treatment, we could throw a ten sided die and record the
result.  We could say, arbitrarily, that a result of 0 means "not cured", and
all the numbers 1 through 9 mean "cured" (typical 10-sided dice have sides
numbered 0 through 9).

We could roll 17 dice to simulate one "trial" in this random world.  For each
trial, we record the number of dice that show numbers 1 through 9 (and not
0).  This will be a number between 0 and 17, and it is the number of patients
"cured" in our simulated trial.

@fig-17-d10s is the result of one such trial we did with a set of 17 10-sided
dice we happened to have to hand:

![One roll of 17 10-sided dice](images/17_d10s.png){#fig-17-d10s}

The trial in @fig-17-d10s shows are four dice with the 0 face uppermost, and
the rest with numbers from 1 through 9.  Therefore, there were 13 out of 17
not-zero numbers, meaning that 13 out of 17 simulated "patients" were "cured"
in this simulated trial.

<!---
Check we have adapted text above to picture.
-->

We could repeat this simulated trial procedure 100 times, and we would then
have 100 counts of the not-zero numbers. Each of the 100 counts would be the
number of patients cured in that trial.  We can ask how many of these 100
counts were equal to 17.  This will give us an estimate of the probability we
would see 17 out of 17 patients cured, given that any one patient has a 90%
chance of cure.  For example, say we saw 15 out of 100 counts were equal to
17.  That would give us an estimate of 15 / 100 or 0.15 or 15%, for the
probability we would see 17 out of 17 patients cured.

So, if Saint Hypothetical General did see 17 out of 17 patients cured with the
standard treatment, they would be a little surprised, because they would only
expect to see that happen 15% of the time.  But they would not be *very*
surprised — 15% of the time is uncommon, but not *very* uncommon.

## Simulating the physical model with the computer

We can use the computer to do something very similar to rolling 17 10-sided
dice, by asking the computer for 17 random whole numbers from 0 through 9.

:::{.callout-note}
## Whole numbers

A whole number is a number that is not negative, and does not have fractional
part (does not have anything after a decimal point).  0 and 1 and 2 and 3 are
whole numbers, but -1 and $\frac{3}{5}$ and 11.3 are not. The whole numbers
from 0 through 9 are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
:::

We have already discussed what we mean by *random* in
@sec-randomness-computer.

::: python
We will be asking the computer to generate many random numbers.  So, before we
start, we again import NumPy and get its *random number generator*:

```{python, opts.label="py_ed"}
import numpy as np

# Ask for NumPy's default random number generator and name
# it `rnd`.  `rnd` is short for "random".
rnd = np.random.default_rng()
```
:::

## From numbers to {{< var array_name >}}s

We [next]{.python} need to prepare the *sequence* of numbers that we want
{{< var np_or_r >}} to select from.

We have already seen the idea that {{< var lang >}} has *values* that are
individual numbers.   Remember, a *variable* is a *named value*.  Here we
attach the name `a` to the value 1.

```{python, opts.label="py_ed"}
a = 1
# Show the value of "a"
a
```

```{r, opts.label="r_ed"}
a <- 1
# Show the value of "a"
a
```

{{< var np_or_r >}} also allows *values* that are *sequences of numbers*.  {{<
var np_or_r >}} calls these sequences *{{< var array_name >}}s*.

::: r
The name *vector* sounds rather technical and mathematical, but the key idea is
only that a *vector* stores a sequence of numbers.
:::

Here we make a {{< var array_name >}} that contains the 10 numbers we will
select from:

```{python, opts.label="py_ed"}
# Make an array of numbers, store with the name "some_numbers".
some_numbers = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# Show the value of "some_numbers"
some_numbers
```

```{r, opts.label="r_ed"}
# Make a vector of numbers, store with the name "some_numbers".
some_numbers <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
# Show the value of "some_numbers"
some_numbers
```

Notice that the value for `some_numbers` is a[n]{.python} {{< var array_name
>}}, and that this value *contains* 10 numbers.

Put another way, `some_number` is now the name we can use for this collection
of 10 values.

{{< var array_name >}}s are very useful for simulations and data analysis, and
we will be using for nearly every example in this book.

## Functions

We can use [`rnd.choice`]{.python}[the `sample` function]{.r} to select a single
value *at random* from the sequence of numbers in `some_numbers`.

```{python, opts.label="py_ed"}
# Select a number from the choices in some_numbers
my_number = rnd.choice(some_numbers)
# Show the value that results.
my_number
```

```{r, opts.label="r_ed"}
# Select a number from the choices in some_numbers
my_number <- sample(some_numbers)
# Show the value that results.
my_number
```

[`rnd.choice`]{.python}[the `sample` function]{.r} is a *function*.

:::python
:::{.callout-note}
## Functions and methods

Actually, to be precise, we should call `rnd.choice` a *method*.  A method is a
*function attached to a value*. In this case the function `choice` is attached
to the value `rnd`.  That's not an important distinction for us at the moment,
so please forgive our strategic imprecision, and let us continue to say that
`rnd.choice` is a function.
:::
:::

We will go into more detail on functions later.  For now, think of a function as a *production line*.  We sent the function raw material to work on.  The production line does some work on the raw materials.  A finished result comes off the other end.

[`rnd.choice`]{.python}[the `sample` function]{.r} is the production line.

We sent it a value to work on, in this case, the value of `some_numbers`.  The
values we send to functions are called *function arguments*.

The production line does some work on this value — in this case, selecting one of the numbers at random.

The production line sends back the finished result — in this case, a number selected at random.  The thing that comes back from a function is called the *return value*.

@fig-function-factory is a diagram illustrating an example run of this production line.

![Example run of the
[`rnd.choice`]{.python}[the `sample` function]{.r} production line
](images/function_factory.jpg){#fig-function-factory}


Here is the same code again, with new comments.

```{python, opts.label="py_ed"}
# Send the value of "some_numbers" to rnd.choice
# some_numbers is the *argument*.
# Put the *return* value from the function into "my_number".
my_number = rnd.choice(some_numbers)
# Show the value that results.
my_number
```

```{r, opts.label="r_ed"}
# Send the value of "some_numbers" to sample.
# some_numbers is the *argument*.
# Put the *return* value from the function into "my_number".
my_number <- sample(some_numbers)
# Show the value that results.
my_number
```

## Sampling from {{< var array_name >}}s

In the code above, we asked
[`rnd.choice`]{.python}[the `sample` function]{.r}
to select a single number at random.

In fact, the people who wrote
[`rnd.choice`]{.python}[the `sample` function]{.r},
wrote it to be flexible in the work that it can do.  In particular, we can tell
[`rnd.choice`]{.python}[the `sample` function]{.r} to select *any number of
values* at random, by adding a new *argument* to the function.

In our case, we would like
[NumPy]{.python}[R]{.r} to select 17 numbers at random from the
sequence of `some_numbers`.

To do this, we add an argument to the function that tells it *how many* numbers we want it to select.

::: r
To get the result we want, we must also add an extra argument: `replace=TRUE`.
`replace=TRUE` tells R to sample `some_numbers` *with replacement*.  We will
soon explain more about what this means, but for now, please take our word for
it that `replace=TRUE` gives use the same effect as rolling the 10-sided dice.
:::

::: todo
Section on resampling with and without replacement in later chapter.
:::

```{python, opts.label="py_ed"}
# Get 17 values from the *some_numbers* array.
# Store the 17 numbers with the name "a"
a = rnd.choice(some_numbers, 17)
# Show the result.
a
```

```{r, opts.label="r_ed"}
# Get 17 values from the *some_numbers* vector.
# Store the 17 numbers with the name "a"
a <- sample(some_numbers, 17, replace=TRUE)
# Show the result.
a
```

As you can see, the function sent back (returned) 17 numbers.  Because it is
sending back more than one number, the thing it sends back is a[n]{.python}
{{< var array_name >}}, where the {{< var array_name >}} has 17 elements.

## Counting results

We now have the code to do the equivalent of throw 17 10-sided dice.  When we
run the code above, we get the equivalent of 17 dice rolls.  This is the basis
for one simulated trial in our simulated world of Saint Hypothetical General.

Our next job is to get the code to count the number of numbers that are not
zero in the {{< var array_name >}} `a`.  That will give us the number of
patients who were cured in our simulated trial.

Another way of asking this question, is to ask how many elements in `a` are greater than zero.

To do this, we use *comparison*.  Here is a *greater than zero* comparison on a single number:

```{python, opts.label="py_ed"}
n = 5
# Is the value of n greater than 0?
# Show the result of the comparison.
n > 0
```

```{r, opts.label="r_ed"}
n <- 5
# Is the value of n greater than 0?
# Show the result of the comparison.
n > 0
```

`>` is a *comparison* — it asks a question about the numbers either side of it.
In this case `>` is asking the question "is the value of `n` greater than 0?"
The value of `n` is 5, so the question becomes, "is 5 greater than 0?" The
answer is Yes, and {{< var lang >}} represents this Yes answer as the value
[`True`]{.python}[`TRUE`]{.r}.

In contrast, here the comparison boils down to "is 0 greater than 0?", to which the answer is No, and {{< var lang >}} represents this as
[`False`]{.python}[`FALSE`]{.r}.

```{python, opts.label="py_ed"}
p = 0
# Is the value of p greater than 0?
# Show the result of the comparison.
p > 0
```

```{r, opts.label="r_ed"}
p <- 0
# Is the value of p greater than 0?
# Show the result of the comparison.
p > 0
```

This is the result of the comparison on a single number.  Now say we do the
same comparison on a[n]{.python} {{< var array_name >}}.  For example, say we
ask the question "is the value of `a` greater than 0"?  Remember, `a` is
a[n]{.python} {{< var array_name >}} containing 17 values.  We are comparing 17
values to one value (0). What answer do you think {{< var np_or_r >}} will
give?  You may want to think a little about this before you read on.

As a reminder, here is the current value for `a`:

```{python, opts.label="py_ed"}
# Show the current value for "a"
a
```

```{r, opts.label="r_ed"}
# Show the current value for "a"
a
```

Now you have had some time to think, here is what happens:

```{python, opts.label="py_ed"}
# Is the value of "a" greater than 0
# Show the result of the comparison.
a > 0
```

```{r, opts.label="r_ed"}
# Is the value of "a" greater than 0?
# Show the result of the comparison.
a > 0
```

There are 17 values in `a`, so the comparison to 0 means there are 17 answers.
{{< var np_or_r >}} therefore returns a[n]{.python} *{{< var array_name >}}*
of 17 elements, containing these 17 answers.  The first answer is the answer to
the question "is the value of the first element of `a` greater than 0", and the
second is the answer to "is the value of the second element of `a` greater than
0".

Let us store the result of this comparison to work on:

```{python, opts.label="py_ed"}
# Is the value of "a" greater than 0
# Store as another array "q".
q = a > 0
# Show the value of q
q
```

```{r, opts.label="r_ed"}
# Is the value of "a" greater than 0?
# Store as another array "q".
q <- a > 0
# Show the value of q
q
```

Notice that there is one
[`True`]{.python}[`TRUE`]{.r}
element in `q` for every element in `a` that was greater than 0.  It only
remains to count the number of
[`True`]{.python}[`TRUE`]{.r}
values in `q`, to get the count of patients in our simulated trial who were
cured.

::: python
NumPy has a function that will do that count of `True` elements, called
`np.count_nonzero`.  It will count the number of elements in an array that are
not equivalent to zero.  `False` is equivalent to 0 in Python:

```{python, opts.label="py_ed"}
# Question: is False equal to 0?
False == 0
```

`True` is equivalent to 1 in Python:

```{python, opts.label="py_ed"}
# Question: is True equal to 0?
True == 1
```

Therefore, `np.count_nozero`, when applied to `q`, will count the number of `True` values in the array:

```{python, opts.label="py_ed"}
# Count the number of True values in "q"
# This is the same as the number of values in "a" that are greater than 0.
count = np.count_nonzero(q)
# Show the result
count
```
:::

::: r
We can use the R function `sum` to count the number of `TRUE` elements in a
vector.  As you can imagine, `sum` adds up all the elements in a vector, to give a single number.  This will work as we want for the `q` vector, because R counts `FALSE` as 0 and `TRUE` as 1:

```{r, opts.label="r_ed"}
# Question: is FALSE equal to 0?
FALSE == 0
```

```{r, opts.label="r_ed"}
# Question: is TRUE equal to 1?
TRUE == 1
```

Therefore, the function `sum`, when applied to `q`, will count the number of
`TRUE` values in the array:

```{r, opts.label="r_ed"}
# Count the number of TRUE values in "q"
# This is the same as the number of values in "a" that are greater than 0.
count <- sum(q)
# Show the result
count
```

## The procedure for one simulated trial

We now have the whole procedure for one simulated trial. We can put the whole procedure in one {{< var cell >}}:

```{python, opts.label="py_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* array.
# Store the 17 numbers with the name "a"
a = rnd.choice(some_numbers, 17)
# Is the value of "a" greater than 0
q = a > 0
# Count the number of True values in "q"
count = np.count_nonzero(q)
# Show the result of this simulated trial.
count
```

```{r, opts.label="r_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* vector.
# Store the 17 numbers with the name "a"
a <- sample(some_numbers, 17, replace=TRUE)
# Is the value of "a" greater than 0?
q <- a > 0
# Count the number of TRUE values in "q"
count <- sum(q)
# Show the result of this simulated trial.
count
# Show the result
```

Now we know how to do one simulated trial, we could just keep running the {{< var cell >}} above, and writing down the result each time.  Once we had run the {{< var cell >}} 100 times, we would have 100 counts.  Then we could look at the 100 counts to see how many were equal to 17 (all 17 simulated patients cured on that trial).  That would at least be much faster than rolling 17 dice 100 times, but we would also like the computer to automate the process of repeating the trial, and keeping track of the counts.   In order to do that, we need to know a little more about arrays, and we need to use a `for` loop.

## More on {{< var array_name >}}s

Since we will be working with {{< var array_name >}}s a lot, it is worth
knowing more about them.

A [NumPy array]{.python}[vector]{.r} is a *container* that stores many elements
of the same type.  You have already seen how we can create a[n]{.python} {{<
var array_name >}} from a sequence of numbers using the
[`np.array`]{.python}[`c()`] function.

```{python, opts.label="py_ed"}
# Make an array of numbers, store with the name "some_numbers".
some_numbers = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# Show the value of "some_numbers"
some_numbers
```

```{r, opts.label="r_ed"}
# Make a vector of numbers, store with the name "some_numbers".
some_numbers <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
# Show the value of "some_numbers"
some_numbers
```

Another way that we can create {{< var array_name >}}s is to use the
[`np.zeros`]{.python}[`numeric`]{.r} function to make a new array where all the
elements are 0.  Before we make our first {{< var array_name >}} of zeros, we need a short diversion to talk about types in {{< var array_name >}}.

Remember we said that a[n]{.python} {{< var array_name >}} stores elements of
the same type.  So far in this chapter, we have only used whole numbers, and
{{< var lang >}} uses the *integer* *type* for whole numbers.

:::{.callout-note}
## Integers
An integer is a number with no fractional part.  All whole numbers are
integers, but the definition of whole numbers does not allow negative numbers,
so the integers are *either* whole numbers, or negative whole numbers. All of
-208, -2, 0, 10, 105 are integers, but $\frac{3}{5}$, -10.3 and 0.2 are not.
:::

When we create a new {{< var array_name >}} of zeros, we tell {{< var np_or_r
>}} what *type* it should use for the new {{< var array_name >}}.

In our case, we want to make a new {{< var array_name >}} of *integers*.

```{python, opts.label="py_ed"}
# Make a new array of integer type, containing 5 zeros.
# store with the name "z".
z = np.zeros(5, dtype=int)
# Show the value of "z"
z
```

```{r, opts.label="r_ed"}
# Make a new vector of integer type, containing 5 zeros.
z <- integer(5)
# Show the value of "z"
z
```

Notice the argument `5` to the [`np.zeros`]{.python}[`integer`]{.r} function.
This tells the function how many zeros we want in the {{< var array_name >}}
that the function will return.

::: python
Notice too the extra `dtype=int` extra argument to `np.zeros`.  This tells
NumPy that it should make an array of integer type.  The `d` in `dtype` refers
to the Data Type of the values in the array.
:::

The are various useful things we can do with this {{< var array_name >}} container.  One is to ask how many elements there are in the {{< var array_name >}} container.  We can use the [`len`]{.python}[`length`]{.r} function to calculate the number of elements in a[n]{.python} {{< var array_name >}}:

```{python, opts.label="py_ed"}
# Show the number of elements in "z"
len(z)
```

```{r, opts.label="r_ed"}
# Show the number of elements in "z"
length(z)
```

Another thing we can do is *set* the value for a particular element in the {{<
var array_name >}}.  To do this, we use square brackets following the {{< var
array_name >}} value, on the left hand side of the equals sign, like this:

```{python, opts.label="py_ed"}
# Set the value of the *first* element in the array.
z[0] = 99
# Show the new contents of the array.
z
```

```{r, opts.label="r_ed"}
# Set the value of the first element in the vector.
z[1] = 99
# Show the new contents of the vector.
z
```

Read the first line of code as "the element at position
[0]{.python}[1]{.r}
gets the value 99".

::: python
Notice that the position number of the first element in the array is 0, and the
position number of the second element is 1.  Think of the position as a
*offset* from the beginning of the array.  The first element is at the
beginning of the array, and so it is at offset (position) 0.  This can be a
little difficult to get used to at first, but you fill find that thinking of
the positions of offsets in this way soon starts to come naturally, and later,
you will also find it helps you avoid some common mistakes when using positions
for getting and setting values.
:::

For practice, let us also set the value of the third element in the {{< var array_name >}}:

```{python, opts.label="py_ed"}
# Set the value of the *third* element in the array.
z[2] = 99
# Show the new contents of the array.
z
```

```{r, opts.label="r_ed"}
# Set the value of the third element in the vector.
z[3] = 99
# Show the new contents of the vector.
z
```

We can also *get* the value of the element at a given position, using the same square-bracket notation:

```{python, opts.label="py_ed"}
# Get the value of the *first* element in the array.
# Store the value with name "v"
v = z[0]
# Show the value we got
v
```

```{r, opts.label="r_ed"}
# Get the value of the *first* element in the array.
# Store the value with name "v"
v = z[0]
# Show the value we got
v
```

Read the first code line here as "v gets the value at position 0 in the {{< var array_name >}}.

Using square brackets to get and set element values is called *indexing* into
the {{< var array_name >}}.

As a preview, let us now imagine that we want to do 100 simulated trials at Saint Hypothetical General.  This will give us 100 counts.  We will want to store the count for each trial.

In order to do this, we make a[n]{.python} {{< var array_name >}} to hold the 100 counts.

```{python, opts.label="py_ed"}
# An array to hold the 100 count values.
counts = np.zeros(100, dtype=int)
```

```{r, opts.label="r_ed"}
# A vector to hold the 100 count values.
counts <- integer(100)
```

Now we could run a single trial to get a single simulated count.  Here we just repeat the code {{< var cell >}} you saw above.  Notice that we can get a different result each time we run this code, because the numbers in `a` are *random* choices from `some_numbers`, and different random numbers will give different counts.

```{python, opts.label="py_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* array.
# Store the 17 numbers with the name "a"
a = rnd.choice(some_numbers, 17)
# Is the value of "a" greater than 0
q = a > 0
# Count the number of True values in "q"
count = np.count_nonzero(q)
# Show the result of this simulated trial.
count
```

```{r, opts.label="r_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* vector.
# Store the 17 numbers with the name "a"
a <- sample(some_numbers, 17, replace=TRUE)
# Is the value of "a" greater than 0?
q <- a > 0
# Count the number of TRUE values in "q"
count <- sum(q)
# Show the result of this simulated trial.
count
# Show the result
```

Now we have the result of a single trial, we can store it as the first number
in the `counts` {{< var array_name >}}:

```{python, opts.label="py_ed"}
# Store the single trial count as the first value in the "counts" array.
counts[0] = count
# Show all the values in the "counts" array.
counts
```

```{r, opts.label="r_ed"}
# Store the single trial count as the first value in the "counts" vector.
counts[1] <- count
# Show all the values in the "counts" vector.
counts
```

Of course we could just keep doing this: run the {{< var cell >}} corresponding
to a trial, above, to get a new count, and then store it at the next position
in the `counts` {{< var array_name >}} with:
[`counts[1] = count`]{.python}[`counts[2] <- count`]{.r},
and so on, but that also looks like a task that the computer is well-suited
for.  And indeed it is, because {{< var lang >}} an excellent way of repeating
the same set of steps many times — the `for` loop.  You have already seen a
preview of the `for` loop in @sec-resampling-method. Here we dive into them in
more depth.

## For-loops in {{< var lang >}}

::: todo
Need to switch for-loops to use integers rather than strings here.

Can we get away without "print"?  Probably not, but then, need to introduce
it.
:::

Imagine a factory robot that slides along a worktable on which several items
have been placed.  It services each of these items, one by one, until it is
done.

So the robot knows *which* item it is operating on, each item is given
a label.

Here is an example:

```{python, opts.label="py_ed"}
for item in ['shoe', 'saddle', 'jacket']:
    print('I am stitching a', item)
```

Here, the robot is working its way through three items: a shoe, a saddle, and a jacket.
As it moves on to each object, it assigns the label ("shoe", "saddle", etc.) to the variable `item`.
The indented block of code under the for is executed for each item, and in this code block `label` can be accessed.
The code above can therefore be unpacked into the following equivalent program:

```{python, opts.label="py_ed"}
item = 'shoe'
print('I am stitching a', item)

item = 'saddle'
print('I am stitching a', item)

item = 'jacket'
print('I am stitching a', item)
```

We used the name `item` here, but any other name would do.
Thus, the following is equivalent:

```{python, opts.label="py_ed"}
for package in ['shoe', 'saddle', 'jacket']:
    print('I am stitching a', package)
```

It is common to use a number as a label in a for loop:

```{python, opts.label="py_ed"}
for i in [0, 1, 2, 3, 4]:
    print('The square of', i, 'is', i * i)
```

When we want to count to a hundred, it becomes laborious to type out the numbers.
For that, Python has a shorthand called `range`:

```{python, opts.label="py_ed"}
for i in range(5):
    print('The square of', i, ' is ', i * i)
```
:::

## Putting it all together

We found that we could construct the code for a single trial.  Here is the code for a single trial, again:

```{python, opts.label="py_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* array.
# Store the 17 numbers with the name "a"
a = rnd.choice(some_numbers, 17)
# Is the value of "a" greater than 0
q = a > 0
# Count the number of True values in "q"
count = np.count_nonzero(q)
# Show the result of this simulated trial.
count
```

```{r, opts.label="r_ed"}
# Procedure for one simulated trial

# Get 17 values from the *some_numbers* vector.
# Store the 17 numbers with the name "a"
a <- sample(some_numbers, 17, replace=TRUE)
# Is the value of "a" greater than 0?
q <- a > 0
# Count the number of TRUE values in "q"
count <- sum(q)
# Show the result of this simulated trial.
count
# Show the result
```

Then we found that we could use {{< var array_name >}}s to store the results of
these trials, and that we could use `for` loops to do many repeats of steps
like those for a single trial.

Now we can put these parts together to do 100 simulated trials at Saint Hypothetical:

```{python, opts.label="py_ed"}
# Procedure for 100 simulated trials.

# An array to store the counts for each trial.
counts = np.zeros(100, dtype=int)

# Repeat the trial procedure 100 times.
for i in range(100):
    # Get 17 values from the *some_numbers* array.
    # Store the 17 numbers with the name "a"
    a = rnd.choice(some_numbers, 17)
    # Is the value of "a" greater than 0
    q = a > 0
    # Count the number of True values in "q"
    count = np.count_nonzero(q)
    # Store the result at the next position in the "counts" array.
    counts[i] = count
    # Now go back and do the next trial until finished.
# Show the result of all 100 trials.
counts
```

```{r, opts.label="r_ed"}
# Procedure for 100 simulated trials.

# An array to store the counts for each trial.
counts <- integer(100)

# Repeat the trial procedure 100 times.
for (i in 1:100) {
    # Get 17 values from the *some_numbers* vector.
    # Store the 17 numbers with the name "a"
    a <- sample(some_numbers, 17, replace=TRUE)
    # Is the value of "a" greater than 0?
    q <- a > 0
    # Count the number of TRUE values in "q"
    count <- sum(q)
    # Store the result at the next position in the "counts" array.
    counts[i] = count
    # Now go back and do the next trial until finished.
}
# Show the result of all 100 trials.
counts
```

Finally, we need to count how many of the trials in `counts` gave a "cured"
count of 17.

We can ask the question whether a single number is equal to 17, like this:

```{python, opts.label="py_ed"}
r = 17
# Is the value of r equal to 17?
# Show the result of the comparison.
r == 17
```

```{r, opts.label="r_ed"}
r <- 17
# Is the value of r equal to 17?
# Show the result of the comparison.
r == 17
```

We can ask this question of *all 100 counts* by asking the question: is the {{< var array_name >}} `counts` equal to 17, like this:

```{python, opts.label="py_ed"}
# Is the value of counts to 17?
were_cured = counts == 17
# Show the result of the comparison.
were_cured
```

```{r, opts.label="r_ed"}
# Is the value of counts to 17?
were_cured <- counts == 17
# Show the result of the comparison.
were_cured
```

Now we need to get the number of
[`True`]{.python}[`TRUE`]{.r}
values in `were_cured`, to find how many trials gave 17 out of 17 cured:

```{python, opts.label="py_ed"}
# Count the number of True values in "were_cured"
# This is the same as the number of values in "counts" that are equal to 17.
n_all_cured = np.count_nonzero(were_cured)
# Show the result of the comparison.
n_all_cured
```

```{r, opts.label="r_ed"}
# Count the number of True values in "were_cured"
# This is the same as the number of values in "counts" that are equal to 17.
n_all_cured <- sum(were_cured)
# Show the result of the comparison.
n_all_cured
```

`n_all_cured` is the number of simulated trials for which all patients were cured.  It only remains to get the proportion of trials for which this was true, and to do this, we divide by the number of trials.

```{python, opts.label="py_ed"}
# Proportion of trials where all patients were cured.
p = n_all_cured / 100
# Show the result
p
```

```{r, opts.label="r_ed"}
# Proportion of trials where all patients were cured.
p <- n_all_cured / 100
# Show the result
p
```

From this experiment, we see that there is roughly a one-in-six chance that
all 17 patients are cured when using a 90% effective treatment.

## Conclusions


Can you see how each of the operations that the computer carries out are
analogous to the operations that you yourself executed when you solved this
problem using 10-sided dice? This is exactly the procedure that we will use to
solve every problem in probability and statistics that we must deal with.
Either we will use a device such as coins or dice, or a random number table as
an analogy for the physical process we are interested in (patients being
cured, in this case), or we will simulate the analogy on the computer using the
{{< var lang >}} program above.

The program above may not seem simple at first glance, but we think you will
find, over the course of this book, that these programs become much simpler to
understand than the older conventional approach to such problems that has
routinely been taught to students for decades.
